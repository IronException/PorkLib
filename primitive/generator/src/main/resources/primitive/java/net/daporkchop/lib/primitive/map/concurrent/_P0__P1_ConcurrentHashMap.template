$$$settings$$$
{
    "params": [
        {
            "genericName": "K",
            "whitelist": [
                "int",
                "long",
                "Object"
            ]
        },
        {
            "genericName": "V",
            "whitelist": [
                "int",
                "long",
                "Object"
            ]
        }
    ]
}
_headers_

import net.daporkchop.lib.primitive.collection.Abstract_P1_Collection;
import net.daporkchop.lib.primitive.collection._P1_Collection;
import net.daporkchop.lib.primitive.collection._P0_Iterator;
import net.daporkchop.lib.primitive.collection._P1_Iterator;
import net.daporkchop.lib.primitive.lambda._P0_Consumer;
import net.daporkchop.lib.primitive.lambda._P1_Consumer;
import net.daporkchop.lib.primitive.lambda._P0__P1_Consumer;
import net.daporkchop.lib.primitive.lambda._P0__P1_Function;
import net.daporkchop.lib.primitive.lambda._P0__P1__P1_Function;
import net.daporkchop.lib.primitive.lambda._P1__P1__P1_Function;
import net.daporkchop.lib.primitive.map._P0__P1_Map;
import net.daporkchop.lib.primitive.map._P0__P1_ConcurrentMap;
import net.daporkchop.lib.primitive.set.Abstract_P0_Set;
import net.daporkchop.lib.primitive.set._P0_Set;

import java.util.AbstractSet;
import java.util.Iterator;
import java.util.function.Consumer;

import static net.daporkchop.lib.primitive.map.concurrent.ConcurrentHashMapHelper.*;

/**
 * Implementation of {@link _P0__P1_ConcurrentMap} backed by a hash table.
 * <p>
 * The implementation is based on the OpenJDK 8 implementation of {@link java.util.concurrent.ConcurrentHashMap}, with various
 * performance tweaks and simplifications.
 * <p>
 * Unlike {@link net.daporkchop.lib.primitive.map.open._P0__P1_OpenHashMap}, this does not allow use of custom hash/equality/comparison
 * functions.
 *
 * @author DaPorkchop_
 */
public class _P0__P1_ConcurrentHashMap_G_ implements _P0__P1_ConcurrentMap_G_, _P0__P1_Consumer_G_ {
    //split into multiple lines to work around generator limitations
    protected static final long SIZECTL = PUnsafe.pork_getOffset(
            _P0__P1_ConcurrentHashMap.class, "sizeCtl");
    protected static final long TRANSFERINDEX = PUnsafe.pork_getOffset(
            _P0__P1_ConcurrentHashMap.class, "transferIndex");
    protected static final long BASECOUNT = PUnsafe.pork_getOffset(
            _P0__P1_ConcurrentHashMap.class, "baseCount");
    protected static final long CELLSBUSY = PUnsafe.pork_getOffset(
        _P0__P1_ConcurrentHashMap.class, "cellsBusy");
    protected static final long CELLVALUE = PUnsafe.pork_getOffset(
        CounterCell.class, "cellValue");
<1!%
    @Getter
    @Accessors(fluent = true)
    protected final _p1_ defaultValue;
%>
    protected transient volatile Node_G_[] table;
    protected transient volatile Node_G_[] nextTable;
    protected transient volatile long baseCount;
    protected transient volatile int sizeCtl;
    protected transient volatile int transferIndex;
    protected transient volatile int cellsBusy;
    protected transient volatile CounterCell[] counterCells;

    //protected transient KeySetView_G_ keySet;
    //protected transient ValuesView_G_ values;
    //protected transient EntrySetView_G_ entrySet;
<1%
    public _P0__P1_ConcurrentHashMap() {
        this(DEFAULT_CAPACITY);
    }

    public _P0__P1_ConcurrentHashMap(int initialCapacity) {
        this.sizeCtl = (notNegative(initialCapacity, "initialCapacity") >= (MAXIMUM_CAPACITY >>> 1)
                ? MAXIMUM_CAPACITY
                : tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
    }

    public _P0__P1_ConcurrentHashMap(@NonNull _P0__P1_Map_Gextends_ m) {
        this(DEFAULT_CAPACITY);
        this.putAll(m);
    }%><1!%
    public _P0__P1_ConcurrentHashMap(_p1_ defaultValue) {
        this(defaultValue, DEFAULT_CAPACITY);
    }

    public _P0__P1_ConcurrentHashMap(_p1_ defaultValue, int initialCapacity) {
        this.defaultValue = defaultValue;
        this.sizeCtl = (notNegative(initialCapacity, "initialCapacity") >= (MAXIMUM_CAPACITY >>> 1)
                ? MAXIMUM_CAPACITY
                : tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
    }

    public _P0__P1_ConcurrentHashMap(_p1_ defaultValue, @NonNull _P0__P1_Map_Gextends_ m) {
        this(defaultValue, DEFAULT_CAPACITY);
        this.putAll(m);
    }

    @Override
    public final _P0__P1_ConcurrentHashMap_G_ defaultValue(_p1_ defaultValue)   {
        throw new UnsupportedOperationException();
    }%>

    @Override
    public int size()   {
        return (int) Math.max(Math.min(this.sumCount(), Integer.MAX_VALUE), 0L);
    }

    @Override
    public boolean isEmpty()    {
        return this.sumCount() <= 0L;
    }

    @Override
    public _p1_ get(_nameP0_ key)   {
        return this.getOrDefault(key, <1!%this.defaultValue%><1%null%>);
    }

    @Override
    public _p1_ getOrDefault(_nameP0_ key, _p1_ defaultValue)   {
        int hash = hash(key) & HASH_BITS;
        Node_G_[] table = this.table;
        if (table == null || table.length <= 0)  {
            return defaultValue;
        }
        Node_G_ node = getArrayVolatile(table, hash & (table.length - 1));
        if (node == null)   {
            return defaultValue;
        } else if (hash == node.hash && eq(key, node.key)) {
            return node.value;
        } else if (node.hash < 0)    { //special node
            return (node = node.find(hash, key)) != null ? node.value : defaultValue;
        }
        while ((node = node.next) != null)  {
            if (hash == node.hash && eq(key, node.key)) {
                return node.value;
            }
        }
        return defaultValue;
    }

    @Override
    public boolean containsKey(_nameP0_ key)    {
        _p1_ defaultValue = <1!%this.defaultValue%><1%null%>;
        return this.getOrDefault(key, defaultValue) != defaultValue;
    }

    @Override
    public boolean containsValue(_nameP1_ value)    {
        if (value == <1!%this.defaultValue%><1%null%>)  {
            return false;
        }
        return false; //todo
    }

    @Override
    public _p1_ put(_p0_ key, _p1_ value)   {
        return this.putVal(key, value, false);
    }

    protected _p1_ putVal(_p0_ key, _p1_ value, boolean onlyIfAbsent)   {
        if (value == <1!%this.defaultValue%><1%null%>)  {
            throw new NullPointerException();
        }
        int hash = hash(key) & HASH_BITS;
        int binCount = 0;
        _p1_ defaultValue = <1!%this.defaultValue%><1%null%>;
        Node_G_[] table = this.table;
        while (true)    {
            if (table == null || table.length == 0) {
                table = this.initTable();
            }
            int index = hash & (table.length - 1);
            Node_G_ node = getArrayVolatile(table, index);
            if (node == null && casArray(table, index, null, new Node<%<>%>(hash, key, value, null)))   {
                break; //bin is empty, we can CAS the entry right into it with no additional synchronization logic
            } else if (node.hash == MOVED)  {
                //TODO: table = this.helpTransfer(table, node);
            } else {
                _p1_ oldValue = defaultValue;
                synchronized (node) {
                    if (getArrayVolatile(table, index) == node) {
                        if (node.hash >= 0) {
                            binCount = 1;
                            for (Node_G_ child = node;; binCount++) {
                                if (hash == child.hash && eq(key, child.key))   {
                                    oldValue = child.value;
                                    if (!onlyIfAbsent)  {
                                        child.value = value;
                                    }
                                    break;
                                }
                                Node_G_ prev = child;
                                if ((child = child.next) == null)   {
                                    prev.next = new Node<%<>%>(hash, key, value, null);
                                    break;
                                }
                            }
                        }/* else if (node instanceof TreeBin) { //TODO
                            binCount = 2;
                            Node_G_ node = ((TreeBin_G_) node).putTreeVal(hash, key, value);
                            if (node != null)   {
                                oldValue = node.value;
                                if (!onlyIfAbsent)  {
                                    child.value = value;
                                }
                            }
                        }*/
                    }
                }
                if (binCount != 0)  {
                    if (binCount >= TREEIFY_THRESHOLD)  {
                        //TODO: this.treeifyBin(table, index);
                    } else if (oldValue != defaultValue)    {
                        return oldValue;
                    }
                    break;
                }
            }
        }
        this.addCount(1L, binCount);
        return defaultValue;
    }
<%
    @SuppressWarnings("unchecked")%>
    protected Node_G_[] initTable() {
        Node_G_[] table = this.table;
        for (; table == null || table.length == 0; table = this.table)  {
            int sizeCtl = this.sizeCtl;
            if (sizeCtl < 0) {
                Thread.yield();
            } else if (PUnsafe.compareAndSwapInt(this, SIZECTL, sizeCtl, -1))   {
                try {
                    if ((table = this.table) == null || table.length == 0)  {
                        int capacity = sizeCtl > 0 ? sizeCtl : DEFAULT_CAPACITY;
                        this.table = table = <%(Node_G_[]) %>new Node[capacity];
                        sizeCtl = capacity - (capacity >>> 2);
                    }
                } finally {
                    this.sizeCtl = sizeCtl;
                }
                break;
            }
        }
        return table;
    }

    protected void addCount(long x, int check)  {
        CounterCell[] counterCells = this.counterCells;
        long baseCount;
        long sum;
        if (counterCells != null || !PUnsafe.compareAndSwapLong(this, BASECOUNT, baseCount = this.baseCount, sum = baseCount + x))   {
            CounterCell cell;
            long value;
            boolean uncontended = true;
            if (counterCells == null || counterCells.length == 0
                || (cell = counterCells[getProbe() & (counterCells.length - 1)]) == null
                || !(uncontended = PUnsafe.compareAndSwapLong(cell, CELLVALUE, baseCount = cell.value, baseCount + x))) {
                this.fullAddCount(x, uncontended);
                return;
            } else if (check <= 1)  {
                return;
            }
            sum = this.sumCount();
        }
        if (check >= 0) {
            Node_G_[] table;
            int sizeCtl;
            while (sum >= (sizeCtl = this.sizeCtl) && (table = this.table) != null && table.length < MAXIMUM_CAPACITY)  {
                int stamp = resizeStamp(table.length);
                if (sizeCtl < 0)    {
                    Node_G_[] nextTable;
                    if (sizeCtl >>> RESIZE_STAMP_SHIFT != stamp || sizeCtl == stamp + 1 || sizeCtl == stamp + MAX_RESIZERS
                        || (nextTable = this.nextTable) == null || this.transferIndex <= 0)  {
                        break;
                    } else if (PUnsafe.compareAndSwapInt(this, SIZECTL, sizeCtl, sizeCtl + 1))  {
                        this.transfer(table, nextTable);
                    }
                } else if (PUnsafe.compareAndSwapInt(this, SIZECTL, sizeCtl, (stamp << RESIZE_STAMP_SHIFT) + 2))    {
                    this.transfer(table, null);
                }
                sum = this.sumCount();
            }
        }
    }

    @Override<1%
    @SuppressWarnings("unchecked")%>
    public _p1_ putIfAbsent(_p0_ key, _p1_ value)  {
        return _EP1_; //todo
    }

    @Override
    public void putAll(@NonNull _P0__P1_Map_Gextends_ m)    {
        m.forEach(this);
    }

    @Override<%
    @SuppressWarnings("unchecked")%>
    public _p1_ remove(_nameP0_ key)    {
        return _EP1_; //todo
    }

    @Override<%
    @SuppressWarnings("unchecked")%>
    public boolean remove(_nameP0_ key, _nameP1_ value)    {
        return false; //todo
    }

    @Override
    public void clear() {
         //todo
    }

    @Override
    public _P0_Set_GP0_ keySet()    {
        /*_P0_Set_GP0_ keySet = this.keySet;
        return keySet == null ? this.keySet = new Keys() : keySet;*/
        return null; //todo
    }

    @Override
    public _P1_Collection_GP1_ values() {
        /*_P1_Collection_GP1_ values = this.valuesCollection;
        return values == null ? this.valuesCollection = new Values() : values;*/
        return null; //todo
    }

    @Override
    public Set<Entry_G_> entrySet()    {
        /*Set<Entry_G_> entrySet = this.entrySet;
        return entrySet == null ? this.entrySet = new Entries() : entrySet;*/
        return null; //todo
    }

    @Override
    public void forEach(@NonNull _P0__P1_Consumer_Gsuper_ action)  {
         //todo
    }

    @Override
    public void replaceAll(@NonNull _P0__P1__P1_Function_G0super1super1extends_ function) {
         //todo
    }

    @Override
    public boolean replace(_p0_ key, _p1_ oldValue, _p1_ newValue)  {
        return false; //todo
    }

    @Override
    public _p1_ replace(_p0_ key, _p1_ value)  {
        return _EP1_; //todo
    }

    @Override
    public _p1_ computeIfAbsent(_p0_ key, @NonNull _P0__P1_Function_G0super1extends_ mappingFunction)  {
        return _EP1_; //todo
    }

    @Override
    public _p1_ computeIfPresent(_p0_ key, @NonNull _P0__P1__P1_Function_G0super1super1extends_ remappingFunction) {
        return _EP1_; //todo
    }

    @Override
    public _p1_ compute(_p0_ key, @NonNull _P0__P1__P1_Function_G0super1super1extends_ remappingFunction) {
        return _EP1_; //todo
    }

    @Override
    public _p1_ merge(_p0_ key, _p1_ value, @NonNull _P1__P1__P1_Function_G1super1super1extends_ remappingFunction) {
        return _EP1_; //todo
    }

    @Override
    @Deprecated
    public void accept(_p0_ key, _p1_ value) {
        this.put(key, value);
    }

    @AllArgsConstructor
    @sun.misc.Contended
    protected static final class CounterCell {
        protected volatile long value;
    }

    protected final long sumCount() {
        CounterCell[] counterCells = this.counterCells;
        long sum = this.baseCount;
        if (counterCells != null)   {
            for (CounterCell cell : counterCells)   {
                if (cell != null)   {
                    sum += cell.value;
                }
            }
        }
        return sum;
    }

    protected final void fullAddCount(long x, boolean wasUncontended)   {
        int probe = getProbe();
        if (probe == 0) {
            initProbe();
            probe = getProbe();
            wasUncontended = true;
        }
        boolean collision = false;
        while (true)    {
            CounterCell[] counterCells = this.counterCells;
            long v;
            if (counterCells != null && counterCells.length > 0)    {
                CounterCell cell = counterCells[probe & (counterCells.length - 1)];
                if (cell == null)   {
                    if (this.cellsBusy == 0)    {
                        CounterCell newCell = new CounterCell(x);
                        if (this.cellsBusy == 0 && PUnsafe.compareAndSwapInt(this, CELLSBUSY, 0, 1))    {
                            try {
                                CounterCell[] counterCells2 = this.counterCells;
                                if (counterCells2 != null && counterCells2.length > 0)  {
                                    int index = probe & (counterCells2.length - 1);
                                    if (counterCells2[index] == null)   {
                                        counterCells2[index] = newCell;
                                        break; //CHM uses a "created" flag to do this, but as far as i can tell this is effectively the same
                                    }
                                }
                            } finally {
                                this.cellsBusy = 0;
                            }
                            continue;
                        }
                    }
                    collision = false;
                } else if (!wasUncontended) {
                    wasUncontended = true;
                } else if (PUnsafe.compareAndSwapLong(cell, CELLVALUE, v = cell.value, v + x))  {
                    break;
                } else if (this.counterCells != counterCells || counterCells.length >= NCPU)    {
                    collision = false;
                } else if (!collision)  {
                    collision = true;
                } else if (this.cellsBusy == 0 && PUnsafe.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                    try {
                        if (this.counterCells == counterCells)  {
                            CounterCell[] newCounterCells = new CounterCell[counterCells.length << 1];
                            System.arraycopy(counterCells, 0, newCounterCells, 0, counterCells.length);
                            this.counterCells = newCounterCells;
                        }
                    } finally {
                        this.cellsBusy = 0;
                    }
                    collision = false;
                    continue;
                }
                probe = advanceProbe(probe);
            } else if (this.cellsBusy == 0 && this.counterCells == counterCells && PUnsafe.compareAndSwapInt(this, CELLSBUSY, 0, 1))    {
                try {
                    if (this.counterCells == counterCells)  {
                        counterCells = new CounterCell[2];
                        counterCells[probe & 1] = new CounterCell(x);
                        this.counterCells = counterCells;
                        break; //CHM uses an "init" flag to do this, but as far as i can tell this is effectively the same
                    }
                } finally {
                    this.cellsBusy = 0;
                }
            } else if (PUnsafe.compareAndSwapLong(this, BASECOUNT, v = this.baseCount, v + x))  {
                break;
            }
        }
    }

    @AllArgsConstructor
    protected static class Node_G_ implements Entry_G_ {
        protected final int hash;
        @Getter
        protected final _p0_ key;
        @Getter
        protected volatile _p1_ value;
        protected volatile Node_G_ next;

        @Override
        public final int hashCode() {
            return hash(this.key) ^ hash(this.value);
        }

        @Override
        public final String toString() {
            return this.key + "=" + this.value;
        }

        @Override
        public final _p1_ setValue(_p1_ value) {
            throw new UnsupportedOperationException();
        }

        @Override
        public final boolean equals(Object o) {
            if (o instanceof Entry)  {<%
                @SuppressWarnings("unchecked")%>
                Entry_G_ e = (Entry_G_) o;
                return eq(this.key, e.getKey()) && eq(this.value, e.getValue());
            } else {
                return false;
            }
        }

        protected Node_G_ find(int h, _nameP0_ k) {
            Node_G_ e = this;
            do {
                if (e.hash == h && eq(e.key, k))   {
                    return e;
                }
            } while ((e = e.next) != null);
            return null;
        }
    }
}
