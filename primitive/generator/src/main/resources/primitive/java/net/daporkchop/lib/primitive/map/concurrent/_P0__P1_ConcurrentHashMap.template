$$$settings$$$
{
    "params": [
        {
            "genericName": "K",
            "whitelist": [
                "int",
                "long",
                "Object"
            ]
        },
        {
            "genericName": "V",
            "whitelist": [
                "int",
                "long",
                "Object"
            ]
        }
    ]
}
_headers_

import net.daporkchop.lib.primitive.collection.Abstract_P1_Collection;
import net.daporkchop.lib.primitive.collection._P1_Collection;
import net.daporkchop.lib.primitive.collection._P0_Iterator;
import net.daporkchop.lib.primitive.collection._P1_Iterator;
import net.daporkchop.lib.primitive.lambda._P0_Consumer;
import net.daporkchop.lib.primitive.lambda._P1_Consumer;
import net.daporkchop.lib.primitive.lambda._P0__P1_Consumer;
import net.daporkchop.lib.primitive.lambda._P0__P1_Function;
import net.daporkchop.lib.primitive.lambda._P0__P1__P1_Function;
import net.daporkchop.lib.primitive.lambda._P1__P1__P1_Function;
import net.daporkchop.lib.primitive.map._P0__P1_Map;
import net.daporkchop.lib.primitive.map._P0__P1_ConcurrentMap;
import net.daporkchop.lib.primitive.set.Abstract_P0_Set;
import net.daporkchop.lib.primitive.set._P0_Set;

import java.util.AbstractSet;
import java.util.Iterator;
import java.util.function.Consumer;

import static net.daporkchop.lib.primitive.map.concurrent.ConcurrentHashMapHelper.*;

/**
 * Implementation of {@link _P0__P1_ConcurrentMap} backed by a hash table.
 * <p>
 * The implementation is based on the OpenJDK 8 implementation of {@link java.util.concurrent.ConcurrentHashMap}, with various
 * performance tweaks and simplifications.
 * <p>
 * Unlike {@link net.daporkchop.lib.primitive.map.open._P0__P1_OpenHashMap}, this does not allow use of custom hash/equality/comparison
 * functions.
 *
 * @author DaPorkchop_
 */
public class _P0__P1_ConcurrentHashMap_G_ implements _P0__P1_ConcurrentMap_G_, _P0__P1_Consumer_G_ {
    //split into multiple lines to work around generator limitations
    protected static final long SIZECTL = PUnsafe.pork_getOffset(
            _P0__P1_ConcurrentHashMap.class, "sizeCtl");
    protected static final long TRANSFERINDEX = PUnsafe.pork_getOffset(
            _P0__P1_ConcurrentHashMap.class, "transferIndex");
    protected static final long BASECOUNT = PUnsafe.pork_getOffset(
            _P0__P1_ConcurrentHashMap.class, "baseCount");
    protected static final long CELLSBUSY = PUnsafe.pork_getOffset(
        _P0__P1_ConcurrentHashMap.class, "cellsBusy");
    protected static final long CELLVALUE = PUnsafe.pork_getOffset(
        CounterCell.class, "cellValue");
<1!%
    @Getter
    @Accessors(fluent = true)
    protected final _p1_ defaultValue;
%>
    protected transient volatile Node_G_[] table;
    protected transient volatile Node_G_[] nextTable;
    protected transient volatile long baseCount;
    protected transient volatile int sizeCtl;
    protected transient volatile int transferIndex;
    protected transient volatile int cellsBusy;
    protected transient volatile CounterCell[] counterCells;

    //protected transient KeySetView_G_ keySet;
    //protected transient ValuesView_G_ values;
    //protected transient EntrySetView_G_ entrySet;
<1%
    public _P0__P1_ConcurrentHashMap() {
        this(DEFAULT_CAPACITY);
    }

    public _P0__P1_ConcurrentHashMap(int initialCapacity) {
        this.sizeCtl = (notNegative(initialCapacity, "initialCapacity") >= (MAXIMUM_CAPACITY >>> 1)
                ? MAXIMUM_CAPACITY
                : tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
    }

    public _P0__P1_ConcurrentHashMap(@NonNull _P0__P1_Map_Gextends_ m) {
        this(DEFAULT_CAPACITY);
        this.putAll(m);
    }%><1!%
    public _P0__P1_ConcurrentHashMap(_p1_ defaultValue) {
        this(defaultValue, DEFAULT_CAPACITY);
    }

    public _P0__P1_ConcurrentHashMap(_p1_ defaultValue, int initialCapacity) {
        this.defaultValue = defaultValue;
        this.sizeCtl = (notNegative(initialCapacity, "initialCapacity") >= (MAXIMUM_CAPACITY >>> 1)
                ? MAXIMUM_CAPACITY
                : tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
    }

    public _P0__P1_ConcurrentHashMap(_p1_ defaultValue, @NonNull _P0__P1_Map_Gextends_ m) {
        this(defaultValue, DEFAULT_CAPACITY);
        this.putAll(m);
    }

    @Override
    public final _P0__P1_ConcurrentHashMap_G_ defaultValue(_p1_ defaultValue)   {
        throw new UnsupportedOperationException();
    }%>

    @Override
    public int size()   {
        return (int) Math.max(Math.min(this.sumCount(), Integer.MAX_VALUE), 0L);
    }

    @Override
    public boolean isEmpty()    {
        return this.sumCount() <= 0L;
    }

    @Override
    public _p1_ get(_nameP0_ key)   {
        return this.getOrDefault(key, <1!%this.defaultValue%><1%null%>);
    }

    @Override
    public _p1_ getOrDefault(_nameP0_ key, _p1_ defaultValue)   {
        int hash = hash(key) & HASH_BITS;
        Node_G_[] table = this.table;
        if (table == null || table.length <= 0)  {
            return defaultValue;
        }
        Node_G_ node = getArrayVolatile(table, hash & (table.length - 1));
        if (node == null)   {
            return defaultValue;
        } else if (hash == node.hash && eq(key, node.key)) {
            return node.value;
        } else if (node.hash < 0)    { //special node
            return (node = node.find(hash, key)) != null ? node.value : defaultValue;
        }
        while ((node = node.next) != null)  {
            if (hash == node.hash && eq(key, node.key)) {
                return node.value;
            }
        }
        return defaultValue;
    }

    @Override
    public boolean containsKey(_nameP0_ key)    {
        _p1_ defaultValue = <1!%this.defaultValue%><1%null%>;
        return this.getOrDefault(key, defaultValue) != defaultValue;
    }

    @Override
    public boolean containsValue(_nameP1_ value)    {
        if (value == <1!%this.defaultValue%><1%null%>)  {
            return false;
        }
        return false; //todo
    }

    @Override
    public _p1_ put(_p0_ key, _p1_ value)   {
        return this.putVal(key, value, false);
    }

    protected _p1_ putVal(_p0_ key, _p1_ value, boolean onlyIfAbsent)   {
        if (value == <1!%this.defaultValue%><1%null%>)  {
            throw new NullPointerException();
        }
        int hash = hash(key) & HASH_BITS;
        int binCount = 0;
        _p1_ defaultValue = <1!%this.defaultValue%><1%null%>;
        Node_G_[] table = this.table;
        while (true)    {
            if (table == null || table.length == 0) {
                table = this.initTable();
            }
            int index = hash & (table.length - 1);
            Node_G_ node = getArrayVolatile(table, index);
            if (node == null && casArray(table, index, null, new Node<%<>%>(hash, key, value, null)))   {
                break; //bin is empty, we can CAS the entry right into it with no additional synchronization logic
            } else if (node.hash == MOVED)  {
                table = this.helpTransfer(table, node);
            } else {
                _p1_ oldValue = defaultValue;
                synchronized (node) {
                    if (getArrayVolatile(table, index) == node) {
                        if (node.hash >= 0) {
                            binCount = 1;
                            for (Node_G_ child = node;; binCount++) {
                                if (hash == child.hash && eq(key, child.key))   {
                                    oldValue = child.value;
                                    if (!onlyIfAbsent)  {
                                        child.value = value;
                                    }
                                    break;
                                }
                                Node_G_ prev = child;
                                if ((child = child.next) == null)   {
                                    prev.next = new Node<%<>%>(hash, key, value, null);
                                    break;
                                }
                            }
                        }/* else if (node instanceof TreeBin) { //TODO
                            binCount = 2;
                            Node_G_ node = ((TreeBin_G_) node).putTreeVal(hash, key, value);
                            if (node != null)   {
                                oldValue = node.value;
                                if (!onlyIfAbsent)  {
                                    child.value = value;
                                }
                            }
                        }*/
                    }
                }
                if (binCount != 0)  {
                    if (binCount >= TREEIFY_THRESHOLD)  {
                        //TODO: this.treeifyBin(table, index);
                    } else if (oldValue != defaultValue)    {
                        return oldValue;
                    }
                    break;
                }
            }
        }
        this.addCount(1L, binCount);
        return defaultValue;
    }

    @Override<1%
    @SuppressWarnings("unchecked")%>
    public _p1_ putIfAbsent(_p0_ key, _p1_ value)  {
        return _EP1_; //todo
    }

    @Override
    public void putAll(@NonNull _P0__P1_Map_Gextends_ m)    {
        this.tryPresize(m.size());
        m.forEach(this);
    }

    @Override<%
    @SuppressWarnings("unchecked")%>
    public _p1_ remove(_nameP0_ key)    {
        return _EP1_; //todo
    }

    @Override<%
    @SuppressWarnings("unchecked")%>
    public boolean remove(_nameP0_ key, _nameP1_ value)    {
        return false; //todo
    }

    @Override
    public void clear() {
         //todo
    }

    @Override
    public _P0_Set_GP0_ keySet()    {
        /*_P0_Set_GP0_ keySet = this.keySet;
        return keySet == null ? this.keySet = new Keys() : keySet;*/
        return null; //todo
    }

    @Override
    public _P1_Collection_GP1_ values() {
        /*_P1_Collection_GP1_ values = this.valuesCollection;
        return values == null ? this.valuesCollection = new Values() : values;*/
        return null; //todo
    }

    @Override
    public Set<Entry_G_> entrySet()    {
        /*Set<Entry_G_> entrySet = this.entrySet;
        return entrySet == null ? this.entrySet = new Entries() : entrySet;*/
        return null; //todo
    }

    @Override
    public void forEach(@NonNull _P0__P1_Consumer_Gsuper_ action)  {
         //todo
    }

    @Override
    public void replaceAll(@NonNull _P0__P1__P1_Function_G0super1super1extends_ function) {
         //todo
    }

    @Override
    public boolean replace(_p0_ key, _p1_ oldValue, _p1_ newValue)  {
        return false; //todo
    }

    @Override
    public _p1_ replace(_p0_ key, _p1_ value)  {
        return _EP1_; //todo
    }

    @Override
    public _p1_ computeIfAbsent(_p0_ key, @NonNull _P0__P1_Function_G0super1extends_ mappingFunction)  {
        return _EP1_; //todo
    }

    @Override
    public _p1_ computeIfPresent(_p0_ key, @NonNull _P0__P1__P1_Function_G0super1super1extends_ remappingFunction) {
        return _EP1_; //todo
    }

    @Override
    public _p1_ compute(_p0_ key, @NonNull _P0__P1__P1_Function_G0super1super1extends_ remappingFunction) {
        return _EP1_; //todo
    }

    @Override
    public _p1_ merge(_p0_ key, _p1_ value, @NonNull _P1__P1__P1_Function_G1super1super1extends_ remappingFunction) {
        return _EP1_; //todo
    }

    @Override
    @Deprecated
    public void accept(_p0_ key, _p1_ value) {
        this.putVal(key, value, false);
    }
<%
    @SuppressWarnings("unchecked")%>
    protected Node_G_[] initTable() {
        Node_G_[] table = this.table;
        for (; table == null || table.length == 0; table = this.table)  {
            int sizeCtl = this.sizeCtl;
            if (sizeCtl < 0) {
                Thread.yield();
            } else if (PUnsafe.compareAndSwapInt(this, SIZECTL, sizeCtl, -1))   {
                try {
                    if ((table = this.table) == null || table.length == 0)  {
                        int capacity = sizeCtl > 0 ? sizeCtl : DEFAULT_CAPACITY;
                        this.table = table = <%(Node_G_[]) %>new Node[capacity];
                        sizeCtl = capacity - (capacity >>> 2);
                    }
                } finally {
                    this.sizeCtl = sizeCtl;
                }
                break;
            }
        }
        return table;
    }

    protected void addCount(long x, int check)  {
        CounterCell[] counterCells = this.counterCells;
        long baseCount;
        long sum;
        if (counterCells != null || !PUnsafe.compareAndSwapLong(this, BASECOUNT, baseCount = this.baseCount, sum = baseCount + x))   {
            CounterCell cell;
            long value;
            boolean uncontended = true;
            if (counterCells == null || counterCells.length == 0
                || (cell = counterCells[getProbe() & (counterCells.length - 1)]) == null
                || !(uncontended = PUnsafe.compareAndSwapLong(cell, CELLVALUE, baseCount = cell.value, baseCount + x))) {
                this.fullAddCount(x, uncontended);
                return;
            } else if (check <= 1)  {
                return;
            }
            sum = this.sumCount();
        }
        if (check >= 0) {
            Node_G_[] table;
            int sizeCtl;
            while (sum >= (sizeCtl = this.sizeCtl) && (table = this.table) != null && table.length < MAXIMUM_CAPACITY)  {
                int stamp = resizeStamp(table.length);
                if (sizeCtl < 0)    {
                    Node_G_[] nextTable;
                    if (sizeCtl >>> RESIZE_STAMP_SHIFT != stamp || sizeCtl == stamp + 1 || sizeCtl == stamp + MAX_RESIZERS
                        || (nextTable = this.nextTable) == null || this.transferIndex <= 0)  {
                        break;
                    } else if (PUnsafe.compareAndSwapInt(this, SIZECTL, sizeCtl, sizeCtl + 1))  {
                        this.transfer(table, nextTable);
                    }
                } else if (PUnsafe.compareAndSwapInt(this, SIZECTL, sizeCtl, (stamp << RESIZE_STAMP_SHIFT) + 2))    {
                    this.transfer(table, null);
                }
                sum = this.sumCount();
            }
        }
    }

    protected Node_G_[] helpTransfer(Node_G_[] table, Node_G_ f)    {
        Node_G_[] nextTable;
        if (table != null && f instanceof ForwardingNode && (nextTable = ((ForwardingNode_G_) f).nextTable) != null)    {
            int stamp = resizeStamp(table.length);
            int sizeCtl;
            while (nextTable == this.nextTable && table == this.table && (sizeCtl = this.sizeCtl) < 0)  {
                if ((sizeCtl >>> RESIZE_STAMP_SHIFT) != stamp || sizeCtl == stamp + 1 || sizeCtl == stamp + MAX_RESIZERS || this.transferIndex <= 0)   {
                    break;
                } else if (PUnsafe.compareAndSwapInt(this, SIZECTL, sizeCtl, sizeCtl + 1))  {
                    this.transfer(table, nextTable);
                    break;
                }
            }
            return nextTable;
        }
        return this.table;
    }

    protected void tryPresize(int size) {
        int capacity = size >= (MAXIMUM_CAPACITY >>> 1) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size >>> 1) + 1);
        int sizeCtl;
        while ((sizeCtl = this.sizeCtl) >= 0)   {
            Node_G_[] table = this.table;
            if (table == null || table.length == 0) {
                int n = Math.max(sizeCtl, capacity);
                if (PUnsafe.compareAndSwapInt(this, SIZECTL, sizeCtl, -1))  {
                    try {
                        if (this.table == table)    {<%
                            Node_G_[] nextTable = <%(Node_G_[]) %>new Node[n];
                            this.table = nextTable;
                            sizeCtl = n - (n >>> 2);
                        }
                    } finally {
                        this.sizeCtl = sizeCtl;
                    }
                }
            } else if (capacity <= sizeCtl || n >= MAXIMUM_CAPACITY)    {
                break;
            } else if (table == this.table) {
                int stamp = resizeStamp(table.length);
                if (sizeCtl < 0)    {
                    Node_G_[] nextTable;
                    if ((sizeCtl >>> RESIZE_STAMP_SHIFT) != stamp || sizeCtl == stamp + 1 || sizeCtl == stamp + MAX_RESIZERS
                        || (nextTable = this.nextTable) == null || this.transferIndex <= 0)    {
                        break;
                    } else if (PUnsafe.compareAndSwapInt(this, SIZECTL, sizeCtl, sizeCtl + 1)    {
                        this.transfer(table, nextTable);
                    }
                } else if (PUnsafe.compareAndSwapInt(this, SIZECTL, sizeCtl, (stamp << RESIZE_STAMP_SHIFT) + 2))    {
                    this.transfer(table, null);
                }
            }
        }
    }

    protected void transfer(Node_G_[] table, Node_G_[] nextTable)   {
        int n = table.length;
        int stride = Math.max(NCPU > 1 ? (n >>> 3) / NCPU : n, MIN_TRANSFER_STRIDE);
        if (nextTable == null)  {
            try {<%
                @SuppressWarnings("unchecked")%>
                Node_G_[] nt = <%(Node_G_[]) %>new Node[n << 1];
                nextTable = nt;
            } catch (Throwable ignored) {
                this.sizeCtl = Integer.MAX_VALUE;
            }
            this.nextTable = nextTable;
            this.transferIndex = n;
        }
        int nextn = nextTable.length;
        ForwardingNode_G_ fwd = new ForwardingNode<%<>%>(nextTable);
        boolean advance = true, finishing = false;
        int i = 0, bound = 0;
        while (true)    {
            while (advance) {
                int nextIndex, nextBound;
                if (--i >= bound || finishing)  {
                    advance = false;
                } else if ((nextIndex = this.transferIndex) <= 0)   {
                    i = -1;
                    advance = false;
                } else if (PUnsafe.compareAndSwapInt(this, TRANSFERINDEX, nextIndex, nextBound = nextIndex > stride ? nextIndex - stride : 0))  {
                    bound = nextBound;
                    i = nextIndex - 1;
                    advance = false;
                }
            }
            Node_G_ f;
            if (i < 0 || i >= n || i + n >= nextn)  {
                if (finishing)  {
                    this.nextTable = null;
                    this.table = nextTable;
                    this.sizeCtl = (n << 1) - (n >>> 1);
                    return;
                }
                int sizeCtl = this.sizeCtl;
                if (PUnsafe.compareAndSwapInt(this, SIZECTL, sizeCtl, sizeCtl - 1)) {
                    if (sizeCtl - 2 != resizeStamp(n) << RESIZE_STAMP_SHIFT)    {
                        return;
                    }
                    finishing = advance = true;
                    i = n;
                }
            } else if ((f = getArrayVolatile(table, i)) == null)    {
                advance = casArray(table, i, null, fwd); //empty bin, forward it to new table
            } else if (f.hash == MOVED)  {
                advance = true; //already processed
            } else {
                synchronized (f)    {
                    if (getArrayVolatile(table, i) != f)    {
                        continue;
                    }
                    if (f.hash >= 0)    {
                        int runBit = f.hash & n;
                        Node_G_ lastRun = f;
                        for (Node_G_ node = f.next; node != null; node = node.next) {
                            int nodeBit = node.hash & n;
                            if (nodeBit != runBit)  {
                                runBit = nodeBit;
                                lastRun = node;
                            }
                        }
                        Node_G_ loNode, hiNode;
                        if (runBit == 0)    {
                            loNode = lastRun;
                            hiNode = null;
                        } else {
                            loNode = null;
                            hiNode = lastRun;
                        }
                        for (Node_G_ node = f; node != lastRun; node = node.next)   {
                            if ((node.hash & n) == 0)   {
                                loNode = new Node<%<>%>(node.hash, node.key, node.value, loNode);
                            } else {
                                hiNode = new Node<%<>%>(node.hash, node.key, node.value, hiNode);
                            }
                        }
                        setArrayVolatile(nextTable, i, loNode);
                        setArrayVolatile(nextTable, i + n, hiNode);
                        setArrayVolatile(table, i, fwd);
                        advance = true;
                    }/* else if (f instanceof TreeBin)    { //TODO
                        TreeBin_G_ t = (TreeBin_G_) f;
                        TreeNode_G_ lo = null, loTail = null;
                        TreeNode_G_ hi = null, hiTail = null;
                        int lc = 0, hc = 0;
                        for (Node_G_ node = t.first; node != null; node = node.next)    {
                            TreeNode_G_ p = new TreeNode<%<>%>(node.hash, node.key, node.value, null, null);
                            if ((node.hash & n) == 0)   {
                                if ((p.prev = loTail) == null)  {
                                    lo = p;
                                } else {
                                    loTail.next = p;
                                }
                                loTail = p;
                                lc++;
                            } else {
                                if ((p.prev = hiTail) == null)  {
                                    hi = p;
                                } else {
                                    hiTail.next = p;
                                }
                                hiTail = p;
                                hc++;
                            }
                        }
                        Node_G_ loNode = lc <= UNTREEIFY_THRESHOLD ? untreeify(lo) : hc != 0 ? new TreeBin<%<>%>(lo) : t;
                        Node_G_ hiNode = hc <= UNTREEIFY_THRESHOLD ? untreeify(hi) : lc != 0 ? new TreeBin<%<>%>(hi) : t;
                        setArrayVolatile(nextTable, i, loNode);
                        setArrayVolatile(nextTable, i + n, hiNode);
                        setArrayVolatile(table, i, fwd);
                        advance = true;
                    }*/
                }
            }
        }
    }

    @AllArgsConstructor
    @sun.misc.Contended
    protected static final class CounterCell {
        protected volatile long value;
    }

    protected final long sumCount() {
        CounterCell[] counterCells = this.counterCells;
        long sum = this.baseCount;
        if (counterCells != null)   {
            for (CounterCell cell : counterCells)   {
                if (cell != null)   {
                    sum += cell.value;
                }
            }
        }
        return sum;
    }

    protected final void fullAddCount(long x, boolean wasUncontended)   {
        int probe = getProbe();
        if (probe == 0) {
            initProbe();
            probe = getProbe();
            wasUncontended = true;
        }
        boolean collision = false;
        while (true)    {
            CounterCell[] counterCells = this.counterCells;
            long v;
            if (counterCells != null && counterCells.length > 0)    {
                CounterCell cell = counterCells[probe & (counterCells.length - 1)];
                if (cell == null)   {
                    if (this.cellsBusy == 0)    {
                        CounterCell newCell = new CounterCell(x);
                        if (this.cellsBusy == 0 && PUnsafe.compareAndSwapInt(this, CELLSBUSY, 0, 1))    {
                            try {
                                CounterCell[] counterCells2 = this.counterCells;
                                if (counterCells2 != null && counterCells2.length > 0)  {
                                    int index = probe & (counterCells2.length - 1);
                                    if (counterCells2[index] == null)   {
                                        counterCells2[index] = newCell;
                                        break; //CHM uses a "created" flag to do this, but as far as i can tell this is effectively the same
                                    }
                                }
                            } finally {
                                this.cellsBusy = 0;
                            }
                            continue;
                        }
                    }
                    collision = false;
                } else if (!wasUncontended) {
                    wasUncontended = true;
                } else if (PUnsafe.compareAndSwapLong(cell, CELLVALUE, v = cell.value, v + x))  {
                    break;
                } else if (this.counterCells != counterCells || counterCells.length >= NCPU)    {
                    collision = false;
                } else if (!collision)  {
                    collision = true;
                } else if (this.cellsBusy == 0 && PUnsafe.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                    try {
                        if (this.counterCells == counterCells)  {
                            CounterCell[] newCounterCells = new CounterCell[counterCells.length << 1];
                            System.arraycopy(counterCells, 0, newCounterCells, 0, counterCells.length);
                            this.counterCells = newCounterCells;
                        }
                    } finally {
                        this.cellsBusy = 0;
                    }
                    collision = false;
                    continue;
                }
                probe = advanceProbe(probe);
            } else if (this.cellsBusy == 0 && this.counterCells == counterCells && PUnsafe.compareAndSwapInt(this, CELLSBUSY, 0, 1))    {
                try {
                    if (this.counterCells == counterCells)  {
                        counterCells = new CounterCell[2];
                        counterCells[probe & 1] = new CounterCell(x);
                        this.counterCells = counterCells;
                        break; //CHM uses an "init" flag to do this, but as far as i can tell this is effectively the same
                    }
                } finally {
                    this.cellsBusy = 0;
                }
            } else if (PUnsafe.compareAndSwapLong(this, BASECOUNT, v = this.baseCount, v + x))  {
                break;
            }
        }
    }

    @AllArgsConstructor
    protected static class Node_G_ implements Entry_G_ {
        protected final int hash;
        @Getter
        protected final _p0_ key;
        @Getter
        protected volatile _p1_ value;
        protected volatile Node_G_ next;

        @Override
        public final int hashCode() {
            return hash(this.key) ^ hash(this.value);
        }

        @Override
        public final String toString() {
            return this.key + "=" + this.value;
        }

        @Override
        public final _p1_ setValue(_p1_ value) {
            throw new UnsupportedOperationException();
        }

        @Override
        public final boolean equals(Object o) {
            if (o instanceof Entry)  {<%
                @SuppressWarnings("unchecked")%>
                Entry_G_ e = (Entry_G_) o;
                return eq(this.key, e.getKey()) && eq(this.value, e.getValue());
            } else {
                return false;
            }
        }

        protected Node_G_ find(int hash, _nameP0_ key) {
            Node_G_ e = this;
            do {
                if (hash == e.hash && eq(key, e.key))   {
                    return e;
                }
            } while ((e = e.next) != null);
            return null;
        }
    }

    protected static final class ForwardingNode_G_ extends Node_G_ {
        protected final Node_G_[] nextTable;

        protected ForwardingNode(Node_G_[] nextTable)   {
            super(MOVED, _EP0_, _EP1_, null);
            this.nextTable = nextTable;
        }

        @Override
        protected Node_G_ find(int hash, _nameP0_ key)  {
            Node_G_[] table = this.nextTable;
            OUT:
            while (true)    {
                if (table == null || table.length == 0) { //CHM also checks if key is null, but there doesn't seem to be any good reason for it...
                    return null;
                }
                Node_G_ node = getArrayVolatile(table, hash & (table.length - 1));
                if (node == null)   {
                    return null;
                }
                while (true)    {
                    if (hash == node.hash && eq(key, node.key)) {
                        return node;
                    } else if (node.hash < 0)   { //special node
                        if (node instanceof ForwardingNode) {
                            table = ((ForwardingNode_G_) node).nextTable;
                            continue OUT;
                        } else {
                            return node.find(hash, key);
                        }
                    } else if ((node = node.next) == null)  {
                        return null;
                    }
                }
            }
        }
    }

    protected static final class ReservationNode_G_ extends Node_G_ {
        protected ReservationNode() {
            super(RESERVED, _EP0_, _EP1_, null);
        }

        @Override
        protected Node_G_ find(int hash, _nameP0_ key) {
            return null;
        }
    }
}
