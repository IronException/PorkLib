$$$settings$$$
{
    "params": [
        {
            "genericName": "K",
            "whitelist": [
                "int",
                "long",
                "Object"
            ]
        },
        {
            "genericName": "V",
            "whitelist": [
                "int",
                "long",
                "Object"
            ]
        }
    ]
}
_headers_

import net.daporkchop.lib.primitive.collection.Abstract_P1_Collection;
import net.daporkchop.lib.primitive.collection._P1_Collection;
import net.daporkchop.lib.primitive.collection._P0_Iterator;
import net.daporkchop.lib.primitive.collection._P1_Iterator;
import net.daporkchop.lib.primitive.lambda._P0_Consumer;
import net.daporkchop.lib.primitive.lambda._P1_Consumer;
import net.daporkchop.lib.primitive.lambda._P0__P1_Consumer;
import net.daporkchop.lib.primitive.lambda._P0__P1_Function;
import net.daporkchop.lib.primitive.lambda._P0__P1__P1_Function;
import net.daporkchop.lib.primitive.lambda._P1__P1__P1_Function;
import net.daporkchop.lib.primitive.map._P0__P1_Map;
import net.daporkchop.lib.primitive.map._P0__P1_ConcurrentMap;
import net.daporkchop.lib.primitive.set.Abstract_P0_Set;
import net.daporkchop.lib.primitive.set._P0_Set;

import java.util.AbstractSet;
import java.util.Iterator;
import java.util.function.Consumer;

import static net.daporkchop.lib.primitive.map.concurrent.ConcurrentHashMapHelper.*;

/**
 * Implementation of {@link _P0__P1_ConcurrentMap} backed by a hash table.
 * <p>
 * The implementation is based on the OpenJDK 8 implementation of {@link java.util.concurrent.ConcurrentHashMap}, with various
 * performance tweaks and simplifications.
 * <p>
 * Unlike {@link net.daporkchop.lib.primitive.map.open._P0__P1_OpenHashMap}, this does not allow use of custom hash/equality/comparison
 * functions.
 *
 * @author DaPorkchop_
 */
public class _P0__P1_ConcurrentHashMap_G_ implements _P0__P1_ConcurrentMap_G_, _P0__P1_Consumer_G_ {
    //split into multiple lines to work around generator limitations
    protected static final long SIZECTL = PUnsafe.pork_getOffset(
            _P0__P1_ConcurrentHashMap.class, "sizeCtl");
    protected static final long TRANSFERINDEX = PUnsafe.pork_getOffset(
            _P0__P1_ConcurrentHashMap.class, "transferIndex");
    protected static final long BASECOUNT = PUnsafe.pork_getOffset(
            _P0__P1_ConcurrentHashMap.class, "baseCount");
    protected static final long CELLSBUSY = PUnsafe.pork_getOffset(_P0__P1_ConcurrentHashMap.class, "cellsBusy");
    protected static final long CELLVALUE = PUnsafe.pork_getOffset(_P0__P1_ConcurrentHashMap.class, "counterCells");
<1!%
    @Getter
    @Accessors(fluent = true)
    protected final _p1_ defaultValue;
%>
    protected transient volatile Node_G_[] table;
    protected transient volatile Node_G_[] nextTable;
    protected transient volatile long baseCount;
    protected transient volatile int sizeCtl;
    protected transient volatile int transferIndex;
    protected transient volatile int cellsBusy;
    protected transient volatile CounterCell[] counterCells;

    //protected transient KeySetView_G_ keySet;
    //protected transient ValuesView_G_ values;
    //protected transient EntrySetView_G_ entrySet;
<1%
    public _P0__P1_ConcurrentHashMap() {
        this(DEFAULT_CAPACITY);
    }

    public _P0__P1_ConcurrentHashMap(int initialCapacity) {
        this.sizeCtl = (notNegative(initialCapacity, "initialCapacity") >= (MAXIMUM_CAPACITY >>> 1)
                ? MAXIMUM_CAPACITY
                : tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
    }

    public _P0__P1_ConcurrentHashMap(@NonNull _P0__P1_Map_Gextends_ m) {
        this(DEFAULT_CAPACITY);
        this.putAll(m);
    }%><1!%
    public _P0__P1_ConcurrentHashMap(_p1_ defaultValue) {
        this(defaultValue, DEFAULT_CAPACITY);
    }

    public _P0__P1_ConcurrentHashMap(_p1_ defaultValue, int initialCapacity) {
        this.defaultValue = defaultValue;
        this.sizeCtl = (notNegative(initialCapacity, "initialCapacity") >= (MAXIMUM_CAPACITY >>> 1)
                ? MAXIMUM_CAPACITY
                : tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
    }

    public _P0__P1_ConcurrentHashMap(_p1_ defaultValue, @NonNull _P0__P1_Map_Gextends_ m) {
        this(defaultValue, DEFAULT_CAPACITY);
        this.putAll(m);
    }

    @Override
    public final _P0__P1_ConcurrentHashMap_G_ defaultValue(_p1_ defaultValue)   {
        throw new UnsupportedOperationException();
    }%>

    @Override
    public int size()   {
        return (int) Math.min(this.size.sum(), Integer.MAX_VALUE);
    }

    @Override
    public boolean isEmpty()    {
        return this.size.sum() <= 0L;
    }

    @Override
    public _p1_ get(_nameP0_ key)   {
        return this.getOrDefault(key, <1!%this.defaultValue%><1%null%>);
    }

    @Override
    public _p1_ getOrDefault(_nameP0_ key, _p1_ defaultValue)   {
        int hash = hash(key) & HASH_BITS;
        Node_G_[] table = this.table;
        if (table == null || table.length <= 0)  {
            return defaultValue;
        }
        Node_G_ node = getArrayVolatile(table, hash & (table.length - 1));
        if (node == null)   {
            return defaultValue;
        } else if (hash == node.hash && eq(key, node.key)) {
            return node.value;
        } else if (node.hash < 0)    { //special node
            return (node = node.find(hash, key)) != null ? node.value : defaultValue;
        }
        while ((node = node.next) != null)  {
            if (hash == node.hash && eq(key, node.key)) {
                return node.value;
            }
        }
        return defaultValue;
    }

    @Override
    public boolean containsKey(_nameP0_ key)    {
        _p1_ defaultValue = <1!%this.defaultValue%><1%null%>;
        return this.getOrDefault(key, defaultValue) != defaultValue;
    }

    @Override
    public boolean containsValue(_nameP1_ value)    {
        if (value == <1!%this.defaultValue%><1%null%>)  {
            return false;
        }
        return false; //todo
    }

    @Override
    public _p1_ put(_p0_ key, _p1_ value)   {
        return this.putVal(key, value, false);
    }

    protected _p1_ putVal(_p0_ key, _p1_ value, boolean onlyIfAbsent)   {
        if (value == <1!%this.defaultValue%><1%null%>)  {
            throw new NullPointerException();
        }
        int hash = hash(key) & HASH_BITS;
        int binCount = 0;
        _p1_ defaultValue = <1!%this.defaultValue%><1%null%>;
        Node_G_[] table = this.table;
        while (true)    {
            if (table == null || table.length == 0) {
                table = this.initTable();
            }
            int index = hash & (table.length - 1);
            Node_G_ node = getArrayVolatile(table, index);
            if (node == null && casArray(table, index, null, new Node<%<>%>(hash, key, value, null)))   {
                break; //bin is empty, we can CAS the entry right into it with no additional synchronization logic
            } else if (node.hash == MOVED)  {
                //TODO: table = this.helpTransfer(table, node);
            } else {
                _p1_ oldValue = defaultValue;
                synchronized (node) {
                    if (getArrayVolatile(table, index) == node) {
                        if (node.hash >= 0) {
                            binCount = 1;
                            for (Node_G_ child = node;; binCount++) {
                                if (hash == child.hash && eq(key, child.key))   {
                                    oldValue = child.value;
                                    if (!onlyIfAbsent)  {
                                        child.value = value;
                                    }
                                    break;
                                }
                                Node_G_ prev = child;
                                if ((child = child.next) == null)   {
                                    prev.next = new Node<%<>%>(hash, key, value, null);
                                    break;
                                }
                            }
                        }/* else if (node instanceof TreeBin) { //TODO
                            binCount = 2;
                            Node_G_ node = ((TreeBin_G_) node).putTreeVal(hash, key, value);
                            if (node != null)   {
                                oldValue = node.value;
                                if (!onlyIfAbsent)  {
                                    child.value = value;
                                }
                            }
                        }*/
                    }
                }
                if (binCount != 0)  {
                    if (binCount >= TREEIFY_THRESHOLD)  {
                        //TODO: this.treeifyBin(table, index);
                    } else if (oldValue != defaultValue)    {
                        return oldValue;
                    }
                    break;
                }
            }
        }
        this.addCount(1L, binCount);
        return defaultValue;
    }
<%
    @SuppressWarnings("unchecked")%>
    protected Node_G_[] initTable() {
        Node_G_[] table = this.table;
        for (; table == null || table.length == 0; table = this.table)  {
            int sizeCtl = this.sizeCtl;
            if (sizeCtl < 0) {
                Thread.yield();
            } else if (PUnsafe.compareAndSwapInt(this, SIZECTL, sizeCtl, -1))   {
                try {
                    if ((table = this.table) == null || table.length == 0)  {
                        int capacity = sizeCtl > 0 ? sizeCtl : DEFAULT_CAPACITY;
                        this.table = table = <%(Node_G_[]) %>new Node[capacity];
                        sizeCtl = capacity - (capacity >>> 2);
                    }
                } finally {
                    this.sizeCtl = sizeCtl;
                }
                break;
            }
        }
        return table;
    }

    @Override<1%
    @SuppressWarnings("unchecked")%>
    public _p1_ putIfAbsent(_p0_ key, _p1_ value)  {
        return _EP1_; //todo
    }

    @Override
    public void putAll(@NonNull _P0__P1_Map_Gextends_ m)    {
        m.forEach(this);
    }

    @Override<%
    @SuppressWarnings("unchecked")%>
    public _p1_ remove(_nameP0_ key)    {
        return _EP1_; //todo
    }

    @Override<%
    @SuppressWarnings("unchecked")%>
    public boolean remove(_nameP0_ key, _nameP1_ value)    {
        return false; //todo
    }

    @Override
    public void clear() {
         //todo
    }

    @Override
    public _P0_Set_GP0_ keySet()    {
        /*_P0_Set_GP0_ keySet = this.keySet;
        return keySet == null ? this.keySet = new Keys() : keySet;*/
        return null; //todo
    }

    @Override
    public _P1_Collection_GP1_ values() {
        /*_P1_Collection_GP1_ values = this.valuesCollection;
        return values == null ? this.valuesCollection = new Values() : values;*/
        return null; //todo
    }

    @Override
    public Set<Entry_G_> entrySet()    {
        /*Set<Entry_G_> entrySet = this.entrySet;
        return entrySet == null ? this.entrySet = new Entries() : entrySet;*/
        return null; //todo
    }

    @Override
    public void forEach(@NonNull _P0__P1_Consumer_Gsuper_ action)  {
         //todo
    }

    @Override
    public void replaceAll(@NonNull _P0__P1__P1_Function_G0super1super1extends_ function) {
         //todo
    }

    @Override
    public boolean replace(_p0_ key, _p1_ oldValue, _p1_ newValue)  {
        return false; //todo
    }

    @Override
    public _p1_ replace(_p0_ key, _p1_ value)  {
        return _EP1_; //todo
    }

    @Override
    public _p1_ computeIfAbsent(_p0_ key, @NonNull _P0__P1_Function_G0super1extends_ mappingFunction)  {
        return _EP1_; //todo
    }

    @Override
    public _p1_ computeIfPresent(_p0_ key, @NonNull _P0__P1__P1_Function_G0super1super1extends_ remappingFunction) {
        return _EP1_; //todo
    }

    @Override
    public _p1_ compute(_p0_ key, @NonNull _P0__P1__P1_Function_G0super1super1extends_ remappingFunction) {
        return _EP1_; //todo
    }

    @Override
    public _p1_ merge(_p0_ key, _p1_ value, @NonNull _P1__P1__P1_Function_G1super1super1extends_ remappingFunction) {
        return _EP1_; //todo
    }

    @Override
    @Deprecated
    public void accept(_p0_ key, _p1_ value) {
        this.put(key, value);
    }

    @AllArgsConstructor
    @sun.misc.Contended
    protected static final class CounterCell {
        protected volatile long value;
    }

    protected final long sumCount() {
        CounterCell[] counterCells = this.counterCells;
        long sum = this.baseCount;
        if (counterCells != null)   {
            for (CounterCell cell : counterCells)   {
                if (cell != null)   {
                    sum += cell.value;
                }
            }
        }
        return sum;
    }

    @AllArgsConstructor
    protected static class Node_G_ implements Entry_G_ {
        protected final int hash;
        @Getter
        protected final _p0_ key;
        @Getter
        protected volatile _p1_ value;
        protected volatile Node_G_ next;

        @Override
        public final int hashCode() {
            return hash(this.key) ^ hash(this.value);
        }

        @Override
        public final String toString() {
            return this.key + "=" + this.value;
        }

        @Override
        public final _p1_ setValue(_p1_ value) {
            throw new UnsupportedOperationException();
        }

        @Override
        public final boolean equals(Object o) {
            if (o instanceof Entry)  {<%
                @SuppressWarnings("unchecked")%>
                Entry_G_ e = (Entry_G_) o;
                return eq(this.key, e.getKey()) && eq(this.value, e.getValue());
            } else {
                return false;
            }
        }

        protected Node_G_ find(int h, _nameP0_ k) {
            Node_G_ e = this;
            do {
                if (e.hash == h && eq(e.key, k))   {
                    return e;
                }
            } while ((e = e.next) != null);
            return null;
        }
    }
}
