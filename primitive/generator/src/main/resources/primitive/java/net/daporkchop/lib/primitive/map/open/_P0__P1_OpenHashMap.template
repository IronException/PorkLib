$$$settings$$$
{
    "params": [
        {
            "genericName": "K",
            "blacklist": [
                "boolean",
                "float",
                "double"
            ]
        },
        {
            "genericName": "V"
        }
    ]
}
_headers_

import net.daporkchop.lib.primitive.collection.Abstract_P1_Collection;
import net.daporkchop.lib.primitive.collection._P1_Collection;
import net.daporkchop.lib.primitive.collection._P0_Iterator;
import net.daporkchop.lib.primitive.collection._P1_Iterator;
import net.daporkchop.lib.primitive.lambda._P0_Consumer;
import net.daporkchop.lib.primitive.lambda._P1_Consumer;
import net.daporkchop.lib.primitive.lambda._P0__P1_Consumer;
import net.daporkchop.lib.primitive.lambda._P0__P1_Function;
import net.daporkchop.lib.primitive.lambda._P0__P1__P1_Function;
import net.daporkchop.lib.primitive.lambda._P1__P1__P1_Function;
import net.daporkchop.lib.primitive.map.Abstract_P0__P1_Map;
import net.daporkchop.lib.primitive.map._P0__P1_Map;
import net.daporkchop.lib.primitive.set.Abstract_P0_Set;
import net.daporkchop.lib.primitive.set._P0_Set;

import static net.daporkchop.lib.common.system.PlatformInfo.*;
import static net.daporkchop.lib.primitive.map.hash.HashMapHelper.*;

/**
 * Implementation of {@link _P0__P1_Map} backed by an open hash table.
 * <p>
 * The table implementation is inspired by a <a href="https://abseil.io/blog/20180927-swisstables">Swiss Table</a>. It makes use
 * of three separate arrays: one array each for keys and values, and a third "index" array which contains a single 8-bit entry
 * for each address in the hash table, enabling fast searches while attempting to minimize cache thrashing.
 * <p>
 * As there are no node objects present to represent entries in the map, all operations relating to {@link #entrySet()} will
 * cause huge numbers of objects to be allocated.
 *
 * @author DaPorkchop_
 */
public class _P0__P1_OpenHashMap_G_ extends Abstract_P0__P1_Map_G_ implements _P0__P1_Consumer_G_ {
    protected byte[] index;
    protected _nameP0_[] keys;
    protected _nameP1_[] values;

    protected int size;
    protected int threshold;
    protected final float loadFactor;

    protected Set<Entry_G_> entrySet;<0%<1%
    protected transient _P0_Set_GP0_ keySet;
    protected transient _P1_Collection_GP1_ valuesCollection;%>%>

    public _P0__P1_OpenHashMap(int initialCapacity, float loadFactor) {
        initialCapacity = tableSizeFor(Math.min(notNegative(initialCapacity, "initialCapacity"), MAXIMUM_CAPACITY));
        checkArg(loadFactor > 0.0f && loadFactor < 1.0f, "Illegal load factor: " + loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = thresholdFor(initialCapacity, this.loadFactor);
        this.index = new byte[initialCapacity];
        this.keys = new _nameP0_[initialCapacity];
        this.values = new _nameP1_[initialCapacity];
    }

    public _P0__P1_OpenHashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    public _P0__P1_OpenHashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
    }

    public _P0__P1_OpenHashMap(@NonNull _P0__P1_Map_Gextends_ m)    {
        this();
        this.putAll(m);
    }

    @Override
    public int size()   {
        return this.size;
    }

    @Override
    public boolean isEmpty()    {
        return this.size == 0;
    }

    @Override<0%
    @SuppressWarnings("unchecked")%>
    public boolean containsKey(_nameP0_ key)    {
        return this.getOffset(this.hash0(_castP0_key), key) >= 0;
    }

    @Override
    public boolean containsValue(_nameP1_ value)    {
        if (this.isEmpty()) {
            return false;
        }
        final byte[] index = this.index;
        final _nameP1_[] values = this.values;
        for (int offset = 0, length = index.length; offset < length; offset++)  { //iterate over whole table
            if ((index[offset] & 0x80) != 0)    { //entry is present
                if (eq(value, values[offset]))    {
                    return true;
                }
            }
        }
        return false;
    }

    @Override<%
    @SuppressWarnings("unchecked")%>
    public _p1_ get(_nameP0_ key)   {
        int offset = this.getOffset(this.hash0(_castP0_key), key);
        return offset >= 0 ? _castP1_this.values[offset] : <1!%this.defaultValue%><1%null%>;
    }

    @Override<%
    @SuppressWarnings("unchecked")%>
    public _p1_ getOrDefault(_nameP0_ key, _p1_ defaultValue)   {
        int offset = this.getOffset(this.hash0(_castP0_key), key);
        return offset >= 0 ? _castP1_this.values[offset] : defaultValue;
    }
<0%
    @SuppressWarnings("unchecked")%>
    protected int getOffset(int hash, _nameP0_ key)  {
        final byte[] index = this.index;
        final _nameP0_[] keys = this.keys;
        final int mask = index.length - 1; //assume table size is always a power of 2
        while (true)    {
            int offset = hash++ & mask;
            byte ie = index[offset];
            if ((ie & 0x80) != 0)   {
                if ((ie ^ 0x80) == (hash & 0x7F) //lowest 7 bits of hash match, check for key equality
                    && this.equals0(_castP0_key, _castP0_keys[offset]))   {
                    return offset;
                }
            } else { //empty entry, key does not exist
                return -1;
            }
        }
    }

    @Override
    public _p1_ put(_p0_ key, _p1_ value)   {
        int offset = this.insert(this.hash0(key), key, value);
        if (offset < 0) { //insert() already handled everything for us
            return <1!%this.defaultValue%><1%null%>;
        }
        final _nameP1_[] values = this.values;<1%
        @SuppressWarnings("unchecked")%>
        _p1_ oldValue = _castP1_values[offset];
        values[offset] = value;
        return oldValue;
    }

    @Override<1%
    @SuppressWarnings("unchecked")%>
    public _p1_ putIfAbsent(_p0_ key, _p1_ value)  {
        int offset = this.insert(this.hash0(key), key, value);
        return offset < 0 ? <1!%this.defaultValue%><1%null%> : _castP1_this.values[offset];
    }

    /**
     * Inserts the given entry into the map.
     * <p>
     * If the entry was already present, returns the entry's offset, otherwise the entry is inserted and {@code -1} is returned.
     */
    protected int insert(int hash, _p0_ key, _p1_ value)    {
        final byte[] index = this.index;
        final _nameP0_[] keys = this.keys;
        final int mask = index.length - 1; //assume table size is always a power of 2
        int offset = hash & mask;
        while (true)    {
            byte ie = index[offset];
            if ((ie & 0x80) != 0)   {
                if ((ie ^ 0x80) == (hash & 0x7F) //lowest 7 bits of hash match, check for key equality
                    && this.equals0(key, _castP0_keys[offset]))   {
                    return offset; //entry exists, do nothing
                }
            } else { //empty entry, insert value
                index[offset] = (byte) (hash | 0x80);
                keys[offset] = key;
                this.values[offset] = value;
                if (this.size++ >= this.threshold)    { //resize table if needed
                    this.rehash((mask + 1) << 1);
                }
                return -1;
            }
            offset = (offset + 1) & hash;
        }
    }
<%
    @SuppressWarnings("unchecked")%>
    protected void rehash(int capacity)  {
        capacity = tableSizeFor(Math.min(notNegative(capacity, "capacity"), MAXIMUM_CAPACITY));
        final byte[] index = this.index; //old arrays
        final _nameP0_[] keys = this.keys;
        final _nameP1_[] values = this.values;
        this.index = new byte[capacity];
        this.keys = new _nameP0_[capacity];
        this.values = new _nameP1_[capacity];
        for (int offset = 0, length = index.length; offset < length; offset++)  {
            if ((index[offset] & 0x80) != 0)    {
                _p0_ key = _castP0_keys[offset];
                checkState(this.insert(this.hash0(key), key, _castP1_values[offset]) >= 0);
            }
        }
    }

    @Override
    public void putAll(@NonNull _P0__P1_Map_Gextends_ m)    {
        m.forEach(this);
    }

    @Override<%
    @SuppressWarnings("unchecked")%>
    public _p1_ remove(_nameP0_ key)    {
        int offset = this.getOffset(this.hash0(_castP0_key), key);
        if (offset < 0) { //entry doesn't exist
            return <1!%this.defaultValue%><1%null%>;
        }
        this.size--;
        _p1_ oldValue = _castP1_this.values[offset];
        this.collapse(offset);
        return oldValue;
    }

    @Override<%
    @SuppressWarnings("unchecked")%>
    public boolean remove(_nameP0_ key, _nameP1_ value)    {
        int hash = this.hash0(_castP0_key);
        int offset = this.getOffset(hash, key);
        if (offset < 0 //entry doesn't exist
            || !eq(value, _castP1_this.values[offset])) { //existing value doesn't match
            return false;
        }
        this.size--;
        this.collapse(offset);
        return true;
    }

    protected void collapse(int offset) {
        final byte[] index = this.index;
        final _nameP0_[] keys = this.keys;
        final _nameP1_[] values = this.values;
        final int mask = index.length - 1; //assume table size is always a power of 2
        while (true)    {
            int prev = offset;
            offset = (offset + 1) & mask;
            byte ie;
            while (true)    {
                if (((ie = index[offset]) & 0x80) == 0)    { //next entry is empty
                    index[prev] = (byte) 0;<0%
                    keys[prev] = null;%><1%
                    values[prev] = null;%>
                    return;
                }
                int curr = this.hash0(_castP0_keys[offset]) & mask;
                if (prev <= offset ? prev >= curr || curr > offset : prev >= curr && curr > offset)  { //next entry cannot be moved backwards
                    break;
                }
                offset = (offset + 1) & mask;
            }
            index[prev] = ie;
            keys[prev] = keys[offset];
            values[prev] = values[offset];
        }
    }

    @Override
    public void clear() {
        if (this.size == 0) {
            return; //do nothing
        }
        final byte[] index = this.index;<0%
        final _nameP0_[] keys = this.keys;%><1%
        final _nameP1_[] values = this.values;%><!%
        Arrays.fill(index, (byte) 0); //neither keys nor values need to be cleared as they are both primitive%><%
        for (int offset = 0, length = index.length; offset < length; offset++)  {
            if ((index[offset] & 0x80) != 0) {<0%
                keys[offset] = null;%><1%
                values[offset] = null;%>
            }
            index[offset] = (byte) 0;
        }%>

        this.size = 0;
    }

    @Override
    public _P0_Set_GP0_ keySet()    {
        _P0_Set_GP0_ keySet = this.keySet;
        return keySet == null ? this.keySet = new Keys() : keySet;
    }

    @Override
    public _P1_Collection_GP1_ values() {
        _P1_Collection_GP1_ values = this.valuesCollection;
        return values == null ? this.valuesCollection = new Values() : values;
    }

    @Override
    public Set<Entry_G_> entrySet()    {
        return null;
    }

    @Override<%
    @SuppressWarnings("unchecked")%>
    public void forEach(@NonNull _P0__P1_Consumer_Gsuper_ action)  {
        final byte[] index = this.index;
        final _nameP0_[] keys = this.keys;
        final _nameP1_[] values = this.values;
        for (int offset = 0, length = index.length; offset < length; offset++)    {
            if ((index[offset] & 0x80) != 0)    {
                action.accept(_castP0_keys[offset], _castP1_values[offset]);
            }
        }
    }

    @Override<%
    @SuppressWarnings("unchecked")%>
    public void replaceAll(@NonNull _P0__P1__P1_Function_G0super1super1extends_ function) {
        final byte[] index = this.index;
        final _nameP0_[] keys = this.keys;
        final _nameP1_[] values = this.values;
        for (int offset = 0, length = index.length; offset < length; offset++)    {
            if ((index[offset] & 0x80) != 0)    {
                values[offset] = function.apply<1!%As_P1_%>(_castP0_keys[offset], _castP1_values[offset]);
            }
        }
    }

    @Override<1%
    @SuppressWarnings("unchecked")%>
    public boolean replace(_p0_ key, _p1_ oldValue, _p1_ newValue)  {
        int offset = this.getOffset(this.hash0(key), key);
        if (offset < 0) {
            return false;
        }
        final _nameP1_[] values = this.values;
        if (!eq(oldValue, _castP1_values[offset])) {
            return false;
        }
        values[offset] = newValue;
        return true;
    }

    @Override<1%
    @SuppressWarnings("unchecked")%>
    public _p1_ replace(_p0_ key, _p1_ value)  {
        int offset = this.getOffset(this.hash0(key), key);
        if (offset < 0) {
            return <1!%this.defaultValue%><1%null%>;
        }
        final _nameP1_[] values = this.values;
        _p1_ oldValue = _castP1_values[offset];
        values[offset] = value;
        return oldValue;
    }

    @Override<1%
    @SuppressWarnings("unchecked")%>
    public _p1_ computeIfAbsent(_p0_ key, @NonNull _P0__P1_Function_G0super1extends_ mappingFunction)  {
        int hash = this.hash0(key);
        int offset = this.getOffset(this.hash0(key), key);
        if (offset < 0) { //key was absent, compute it
            _p1_ value = mappingFunction.apply<1!%As_P1_%>(key);
            if (value != <1!%this.defaultValue%><1%null%>)  {
                this.insert(hash, key, value);
            }
            return value;
        }
        return _castP1_this.values[offset];
    }

    @Override
    public _p1_ computeIfPresent(_p0_ key, @NonNull _P0__P1__P1_Function_G0super1super1extends_ remappingFunction) {
        int offset = this.getOffset(this.hash0(key), key);
        if (offset < 0) { //key was absent, do nothing
            return <1!%this.defaultValue%><1%null%>;
        }
        final _nameP1_[] values = this.values;<1%
        @SuppressWarnings("unchecked")%>
        _p1_ oldValue = _castP1_values[offset];
        _p1_ newValue = remappingFunction.apply<1!%As_P1_%>(key, oldValue);
        if (newValue != <1!%this.defaultValue%><1%null%>)   {
            this.values[offset] = newValue; //re-use existing entry
        } else {
            this.collapse(offset);
            this.size--;
        }
        return newValue;
    }

    @Override
    public _p1_ compute(_p0_ key, @NonNull _P0__P1__P1_Function_G0super1super1extends_ remappingFunction) {
        int hash = this.hash0(key);
        int offset = this.getOffset(this.hash0(key), key);
        final _nameP1_[] values = this.values;
        _p1_ defaultValue = <1!%this.defaultValue%><1%null%>;<1%
        @SuppressWarnings("unchecked")%>
        _p1_ oldValue = offset < 0 ? defaultValue : _castP1_values[offset];
        _p1_ newValue = remappingFunction.apply<1!%As_P1_%>(key, oldValue);
        if (offset < 0) { //key was absent, insert it
            if (newValue != defaultValue)  {
                this.insert(hash, key, newValue);
            }
        } else {
            if (newValue != defaultValue)   {
                this.values[offset] = newValue; //re-use existing entry
            } else {
                this.collapse(offset);
                this.size--;
            }
        }
        return newValue;
    }

    @Override
    public _p1_ merge(_p0_ key, _p1_ value, @NonNull _P1__P1__P1_Function_G1super1super1extends_ remappingFunction) {
        int hash = this.hash0(key);
        int offset = this.getOffset(this.hash0(key), key);
        final _nameP1_[] values = this.values;
        _p1_ defaultValue = <1!%this.defaultValue%><1%null%>;<1%
        @SuppressWarnings("unchecked")%>
        _p1_ oldValue = offset < 0 ? defaultValue : _castP1_values[offset];
        _p1_ newValue = remappingFunction.apply<1!%As_P1_%>(oldValue, value);
        if (offset < 0) { //key was absent, insert it
            if (newValue != defaultValue)  {
                this.insert(hash, key, newValue);
            }
        } else {
            if (newValue != defaultValue)   {
                this.values[offset] = newValue; //re-use existing entry
            } else {
                this.collapse(offset);
                this.size--;
            }
        }
        return newValue;
    }

    @Override
    @Deprecated
    public void accept(_p0_ key, _p1_ value) {
        this.put(key, value);
    }

    protected int hash0(_p0_ key)    {
        int hash = hash(key);
        return (hash >>> 16) ^ hash; //the lowest 7 hash bits are the important ones, so smear entropy down
    }

    protected boolean equals0(_p0_ k1, _p0_ k2) {
        return eq(k1, k2);
    }<0%

    /**
     * Extension of {@link _P0__P1_OpenHashMap} which compares keys by identity.
     *
     * @author DaPorkchop_
     */
    public static final class Identity_G_ extends _P0__P1_OpenHashMap_G_ {
        public Identity(int initialCapacity, float loadFactor) {
            super(initialCapacity, loadFactor);
        }

        public Identity(int initialCapacity) {
            super(initialCapacity);
        }

        public Identity() {
            super();
        }

        public Identity(@NonNull _P0__P1_Map_Gextends_ m)    {
            super(m);
        }

        @Override
        protected int hash0(_p0_ key)    {
            return key != null ? System.identityHashCode(key) : 0;
        }

        @Override
        protected boolean equals0(_p0_ k1, _p0_ k2) {
            return k1 == k2;
        }
    }%>

    protected abstract class BaseIterator {
        protected final byte[] index = _P0__P1_OpenHashMap.this.index;
        protected int offset = this.findNext(0);
        protected int current = -1;

        protected int findNext(int offset)    {
            final byte[] index = this.index;
            for (int length = index.length; offset < length; offset++)  {
                if ((index[offset] & 0x80) != 0)    {
                    return offset;
                }
            }
            return -1;
        }

        public boolean hasNext()    {
            return this.offset >= 0;
        }

        public int nextOffset() {
            int offset = this.offset;
            if (offset < 0) {
                throw new NoSuchElementException();
            }
            this.offset = this.findNext(offset + 1);
            return this.current = offset;
        }

        public void remove()    {
            int current = this.current;
            if (current < 0)    {
                throw new NoSuchElementException();
            }
            this.current = -1;
            _P0__P1_OpenHashMap.this.collapse(current);
            _P0__P1_OpenHashMap.this.size--;
        }
    }

    protected class Keys extends Abstract_P0_Set_GP0_ {
        @Override
        public _P0_Iterator_GP0_ iterator() {
            class KeyIterator extends BaseIterator implements _P0_Iterator_GP0_ {
                protected final _nameP0_[] keys = _P0__P1_OpenHashMap.this.keys;

                @Override<0%
                @SuppressWarnings("unchecked")%>
                public _p0_ next<0!%_P0_%>()  {
                    return _castP0_this.keys[this.nextOffset()];
                }
            }
            return new KeyIterator();
        }

        @Override
        public int size()   {
            return _P0__P1_OpenHashMap.this.size();
        }

        @Override
        public boolean isEmpty()    {
            return _P0__P1_OpenHashMap.this.isEmpty();
        }

        @Override
        public void clear() {
            _P0__P1_OpenHashMap.this.clear();
        }

        @Override
        public boolean contains(_nameP0_ key)  {
            return _P0__P1_OpenHashMap.this.containsKey(key);
        }

        @Override<0%
        @SuppressWarnings("unchecked")%>
        public boolean remove(_nameP0_ key)   {
            int offset = _P0__P1_OpenHashMap.this.getOffset(_P0__P1_OpenHashMap.this.hash0(_castP0_key), key);
            if (offset < 0) { //entry doesn't exist
                return false;
            }
            _P0__P1_OpenHashMap.this.size--;
            _P0__P1_OpenHashMap.this.collapse(offset);
            return true;
        }

        @Override<0%
        @SuppressWarnings("unchecked")%>
        public void forEach(@NonNull _P0_Consumer_GsuperP0_ action) {
            final byte[] index = _P0__P1_OpenHashMap.this.index;
            final _nameP0_[] keys = _P0__P1_OpenHashMap.this.keys;
            for (int offset = 0, length = index.length; offset < length; offset++)  {
                if ((index[offset] & 0x80) != 0)    {
                    action.accept(_castP0_keys[offset]);
                }
            }
        }
    }

    protected class Values extends Abstract_P1_Collection_GP1_ {
        @Override
        public _P1_Iterator_GP1_ iterator() {
            class ValueIterator extends BaseIterator implements _P1_Iterator_GP1_ {
                protected final _nameP1_[] values = _P0__P1_OpenHashMap.this.values;

                @Override<1%
                @SuppressWarnings("unchecked")%>
                public _p1_ next<1!%_P1_%>()  {
                    return _castP1_this.values[this.nextOffset()];
                }
            }
            return new ValueIterator();
        }

        @Override
        public int size()   {
           return _P0__P1_OpenHashMap.this.size();
        }

        @Override
        public boolean isEmpty()    {
           return _P0__P1_OpenHashMap.this.isEmpty();
        }

        @Override
        public void clear() {
           _P0__P1_OpenHashMap.this.clear();
        }

        @Override
        public boolean contains(_nameP1_ value)  {
           return _P0__P1_OpenHashMap.this.containsValue(value);
        }

        @Override<1%
        @SuppressWarnings("unchecked")%>
        public void forEach(@NonNull _P1_Consumer_GsuperP1_ action) {
            final byte[] index = _P0__P1_OpenHashMap.this.index;
            final _nameP1_[] values = _P0__P1_OpenHashMap.this.values;
            for (int offset = 0, length = index.length; offset < length; offset++)  {
                if ((index[offset] & 0x80) != 0)    {
                    action.accept(_castP1_values[offset]);
                }
            }
        }
    }
}
