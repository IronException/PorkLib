$$$settings$$$
{
    "params": [
        {
            "genericName": "K",
            "blacklist": [
                "boolean",
                "float",
                "double"
            ]
        },
        {
            "genericName": "V"
        }
    ]
}
_headers_

import net.daporkchop.lib.primitive.collection._P1_Collection;
import net.daporkchop.lib.primitive.lambda._P0__P1_Consumer;
import net.daporkchop.lib.primitive.lambda._P0__P1_Function;
import net.daporkchop.lib.primitive.lambda._P0__P1__P1_Function;
import net.daporkchop.lib.primitive.lambda._P1__P1__P1_Function;
import net.daporkchop.lib.primitive.map.Abstract_P0__P1_Map;
import net.daporkchop.lib.primitive.map._P0__P1_Map;
import net.daporkchop.lib.primitive.set._P0_Set;

import static net.daporkchop.lib.common.system.PlatformInfo.*;
import static net.daporkchop.lib.primitive.map.hash.HashMapHelper.*;

/**
 * Implementation of {@link _P0__P1_Map} backed by an open hash table.
 * <p>
 * The table implementation is inspired by a <a href="https://abseil.io/blog/20180927-swisstables">Swiss Table</a>. It makes use
 * of three separate arrays: one array each for keys and values, and a third "index" array which contains a single 8-bit entry
 * for each address in the hash table, enabling fast searches while attempting to minimize cache thrashing.
 * <p>
 * As there are no node objects present to represent entries in the map, all operations relating to {@link #entrySet()} will
 * cause huge numbers of objects to be allocated.
 *
 * @author DaPorkchop_
 */
public class _P0__P1_OpenHashMap_G_ extends Abstract_P0__P1_Map_G_ {
    protected byte[] index;
    protected _nameP0_[] keys;
    protected _nameP1_[] values;

    protected int size;
    protected int threshold;
    protected final float loadFactor;

    protected Set<Entry_G_> entrySet;

    public _P0__P1_OpenHashMap(int initialCapacity, float loadFactor) {
        initialCapacity = Math.min(notNegative(initialCapacity, "initialCapacity"), MAXIMUM_CAPACITY);
        checkArg(loadFactor > 0.0f && loadFactor < 1.0f, "Illegal load factor: " + loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = thresholdFor(initialCapacity, this.loadFactor);
        this.index = new byte[initialCapacity];
        this.keys = new _nameP0_[initialCapacity];
        this.values = new _nameP1_[initialCapacity];
    }

    public _P0__P1_OpenHashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    public _P0__P1_OpenHashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
    }

    public _P0__P1_OpenHashMap(@NonNull _P0__P1_Map_Gextends_ m)    {
        this();
        this.putAll(m);
    }

    @Override
    public int size()   {
        return this.size;
    }

    @Override
    public boolean isEmpty()    {
        return this.size == 0;
    }

    @Override
    public boolean containsKey(_nameP0_ key)    {
        return this.getOffset(this.hash0(key), key) >= 0;
    }

    @Override
    public boolean containsValue(_nameP1_ value)    {
        if (this.isEmpty()) {
            return false;
        }
        final byte[] index = this.index;
        final _nameP1_[] values = this.values;
        for (int offset = 0, length = index.length; offset < length; offset++)  { //iterate over whole table
            if ((index[offset] & 0x80) != 0)    { //entry is present
                if (eq(value, values[offset]))    {
                    return true;
                }
            }
        }
        return false;
    }

    @Override<1%
    @SuppressWarnings("unchecked")%>
    public _p1_ get(_nameP0_ key)   {
        int offset = this.getOffset(this.hash0(key), key);
        return offset >= 0 ? _castP1_this.values[key] : <1!%this.defaultValue%><1%null%>;
    }

    @Override<1%
    @SuppressWarnings("unchecked")%>
    public _p1_ getOrDefault(_nameP0_ key, _p1_ defaultValue)   {
        int offset = this.getOffset(this.hash0(key), key);
        return offset >= 0 ? _castP1_this.values[key] : defaultValue;
    }
<0%
    @SuppressWarnings("unchecked")%>
    protected int getOffset(int hash, _nameP0_ key)  {
        final byte[] index = this.index;
        final _nameP0_[] keys = this.keys;
        final int mask = index.length - 1; //assume table size is always a power of 2
        while (true)    {
            int offset = hash++ & mask;
            byte ie = index[offset];
            if ((ie & 0x80) != 0)   {
                if ((ie ^ 0x80) == (hash & 0x7F) //lowest 7 bits of hash match, check for key equality
                    && this.equals0(_castP0_key, _castP0_keys[offset]))   {
                    return offset;
                }
            } else { //empty entry, key does not exist
                return -1;
            }
        }
    }

    @Override
    public _p1_ put(_p0_ key, _p1_ value)   {
        int offset = this.insert(this.hash0(key), key, value);
        if (offset < 0) { //insert() already handled everything for us
            return <1!%this.defaultValue%><1%null%>;
        }
        final _nameP1_[] values = this.values;<1%
        @SuppressWarnings("unchecked")%>
        _p1_ oldValue = _castP1_values[offset];
        values[offset] = value;
        return oldValue;
    }

    /**
     * Inserts the given entry into the map.
     * <p>
     * If the entry was already present, returns the entry's offset, otherwise the entry is inserted and {@code -1} is returned.
     */
    protected int insert(int hash, _p0_ key, _p1_ value)    {
        final byte[] index = this.index;
        final _nameP0_[] keys = this.keys;
        final int mask = index.length - 1; //assume table size is always a power of 2
        int offset = hash & mask;
        while (true)    {
            byte ie = index[offset];
            if ((ie & 0x80) != 0)   {
                if ((ie ^ 0x80) == (hash & 0x7F) //lowest 7 bits of hash match, check for key equality
                    && this.equals0(key, _castP0_keys[offset]))   {
                    return offset; //entry exists, do nothing
                }
            } else { //empty entry, insert value
                index[offset] = (byte) (hash | 0x80);
                keys[offset] = key;
                this.values[offset] = value;
                if (this.size++ >= this.threshold)    { //resize table if needed
                    this.resize((mask + 1) << 1);
                }
                return -1;
            }
            offset = (offset + 1) & hash;
        }
    }

    /**
     * Removes the mapping with the given key from this map.
     *
     * @return the value previously mapped to the given key, or <1!%{@link #defaultValue()}%><1%{@code null}%> if it did not exist
     */
    _p1_ remove(_nameP0_ key);

    /**
     * Copies all of the mappings from the specified map to this map.
     * <p>
     * The result is the same as if {@link #put(_nameP0_, _nameP1_)} were called individually for each mapping in the given map.
     */
    void putAll(@NonNull _P0__P1_Map_Gextends_ m);

    /**
     * Removes all of the mappings from this map.
     */
    void clear();

    /**
     * @return a {@link _P0_Set} view of the keys contained in this map
     */
    _P0_Set_GP0_ keySet();

    /**
     * @return a {@link _P1_Collection} view of the values contained in this map
     */
    _P1_Collection_GP1_ values();

    /**
     * @return a {@link _P0_Set} view of the entries contained in this map
     */
    Set<Entry_G_> entrySet();

    /**
     * Performs the given action for each entry in this map until all entries have been processed or the action throws an exception.
     */
    default void forEach(@NonNull _P0__P1_Consumer_Gsuper_ action)  {
        for (Entry_G_ entry : this.entrySet()) {
            _p0_ k;
            _p1_ v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch (IllegalStateException e)   {
                throw new ConcurrentModificationException(e);
            }
            action.accept(k, v);
        }
    }

    /**
     * Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the
     * function throws an exception.
     */
    default void replaceAll(@NonNull _P0__P1__P1_Function_G0super1super1extends_ function) {
        for (Entry_G_ entry : this.entrySet()) {
            _p0_ k;
            _p1_ v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch (IllegalStateException e)   {
                throw new ConcurrentModificationException(e);
            }
            v = function.apply<1!%As_P1_%>(k, v);
            try {
                entry.setValue(v);
            } catch (IllegalStateException e)   {
                throw new ConcurrentModificationException(e);
            }
        }
    }

    /**
     * Associates the given value with the given key in this map.
     * <p>
     * If the map previously contained a mapping for the key, the old value is returned and the map is not modified.
     *
     * @return the value previously mapped to the given key, or <1!%{@link #defaultValue()}%><1%{@code null}%> if it did not previously exist
     */
    default _p1_ putIfAbsent(_p0_ key, _p1_ value)  {
        _p1_ v = this.get(key);
        return v == <1!%this.defaultValue()%><1%null%> ? this.put(key, value) : v;
    }

    /**
     * Removes the entry for the given key only if it is currently mapped to the given value.
     *
     * @return whether or not the entry was removed
     */
    default boolean remove(_nameP0_ key, _nameP1_ value)    {
        _nameP1_ curValue = this.get(key);
        if (!equals(value, curValue)) {
            return false;
        }
        this.remove(key);
        return true;
    }

    /**
     * Removes the value for the given key only if it is currently mapped to the given value.
     *
     * @return whether or not the value was replaced
     */
    default boolean replace(_p0_ key, _p1_ oldValue, _p1_ newValue)  {
        _p1_ curValue = this.get(key);
        if (!equals(value, curValue)) {
            return false;
        }
        this.put(key, newValue);
        return true;
    }

    /**
     * Replaces the value for the given key.
     * <p>
     * If the map did not previously contain a mapping for the key, the map is not modified.
     *
     * @return the value previously mapped to the given key, or <1!%{@link #defaultValue()}%><1%{@code null}%> if it did not previously exist
     */
    default _p1_ replace(_p0_ key, _p1_ value)  {
        _p1_ curValue = this.get(key);
        return curValue == <1!%this.defaultValue()%><1%null%> ? curValue : this.put(key, value);
    }

    /**
     * Gets the value mapped to the given key, computing it using the given function and storing it in the map if absent.
     *
     * @return the value
     */
    default _p1_ computeIfAbsent(_p0_ key, @NonNull _P0__P1_Function_G0super1extends_ mappingFunction)  {
        _p1_ v = this.get(key);
        _p1_ defaultValue = <1!%this.defaultValue()%><1%null%>;
        if (v == defaultValue && (v = mappingFunction.apply<1!%As_P1_%>(key)) != defaultValue)   {
            this.put(key, v);
        }
        return v;
    }

    /**
     * If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value.
     * <p>
     * If the function returns <1!%{@link #defaultValue()}%><1%{@code null}%>, the mapping is removed.
     *
     * @return the new value, or <1!%{@link #defaultValue()}%><1%{@code null}%> if none
     */
    default _p1_ computeIfPresent(_p0_ key, @NonNull _P0__P1__P1_Function_G0super1super1extends_ remappingFunction) {
        _p1_ oldValue = this.get(key);
        _p1_ defaultValue = <1!%this.defaultValue()%><1%null%>;
        if (oldValue != defaultValue)   {
            _p1_ newValue = remappingFunction.apply<1!%As_P1_%>(key, oldValue);
            if (newValue != defaultValue)   {
                this.put(key, newValue);
                return newValue;
            } else {
                this.remove(key);
                return defaultValue;
            }
        } else {
            return defaultValue;
        }
    }

    /**
     * Attempts to compute a mapping for the specified key and its current mapped value (or <1!%{@link #defaultValue()}%><1%{@code null}%> if
     * there is no current mapping).
     * <p>
     * If the function returns <1!%{@link #defaultValue()}%><1%{@code null}%>, the mapping is removed.
     *
     * @return the new value, or <1!%{@link #defaultValue()}%><1%{@code null}%> if none
     */
    default _p1_ compute(_p0_ key, @NonNull _P0__P1__P1_Function_G0super1super1extends_ remappingFunction) {
        _p1_ oldValue = this.get(key);
        _p1_ newValue = remappingFunction.apply<1!%As_P1_%>(key, oldValue);

        _p1_ defaultValue = <1!%this.defaultValue()%><1%null%>;
        if (newValue == defaultValue)   {
            if (oldValue != defaultValue)   {
                this.remove(key);
            }
            return defaultValue;
        } else {
            this.put(key, newValue);
            return newValue;
        }
    }

    /**
     * If the specified key is not already associated with a value, associates it with the given value. Otherwise, replaces the associated
     * value with the results of the given remapping function, or removes it if the result is <1!%{@link #defaultValue()}%><1%{@code null}%>.
     *
     * @return the new value, or <1!%{@link #defaultValue()}%><1%{@code null}%> if none
     */
    default _p1_ merge(_p0_ key, _p1_ value, @NonNull _P1__P1__P1_Function_G1super1super1extends_ remappingFunction) {
        _p1_ oldValue = this.get(key);

        _p1_ defaultValue = <1!%this.defaultValue()%><1%null%>;
        _p1_ newValue = oldValue == defaultValue ? value : remappingFunction.apply<1!%As_P1_%>(oldValue, value);
        if (newValue == defaultValue)   {
            this.remove(key);
        } else {
            this.put(key, newValue);
        }
        return newValue;
    }

    protected int hash0(_p0_ key)    {
        int hash = hash(key);
        return (hash >>> 16) ^ hash; //the lowest 7 hash bits are the important ones, so smear entropy down
    }

    protected boolean equals0(_p0_ k1, _p0_ k2) {
        return eq(k1, k2);
    }
}
