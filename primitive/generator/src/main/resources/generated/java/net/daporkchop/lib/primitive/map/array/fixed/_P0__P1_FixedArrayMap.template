$$$settings$$$
{
    "P0": {
        "blacklist": [
            "boolean",
            "float",
            "double"
        ]
    }
}
_headers_

import net.daporkchop.lib.math.primitive.BinMath;

import net.daporkchop.lib.primitive.function.biconsumer._P0__P1_BiConsumer;
import net.daporkchop.lib.primitive.function.consumer._P0_Consumer;
import net.daporkchop.lib.primitive.function.consumer._P1_Consumer;
import net.daporkchop.lib.primitive.map._P0__P1_Map;

/**
 * An implementation of {@link _P0__P1_Map} backed by a fixed-size array.
 *
 * @author DaPorkchop_
 */
public class _P0__P1_FixedArrayMap_gH_ implements _P0__P1_Map_gH_ {
    protected _nameP0_[] keys;
    protected _nameP1_[] values;
    protected final int mask;
    protected int size = 0;

    public _P0__P1_FixedArrayMap(int size)  {
        this(size, true);
    }

    /**
     * Creates a new {@link _P0__P1_FixedArrayMap}.
     *
     * @param size      the size of the backing arrays. Must be a power of 2
     * @param storeKeys whether or not to store keys. Refer to package-info.java in the parent package
     *                  for more information.
     */
    public _P0__P1_FixedArrayMap(int size, boolean storeKeys)  {
        if (!BinMath.isPow2(size))  {
            throw new IllegalArgumentException("size must be a power of 2!");
        } else {
            this.keys = storeKeys ? new _nameP0_[size] : null;
            this.values = new _nameP1_[size];
            this.mask = size - 1;

            this.clear();
        }
    }

    @Override
    public void put(_p0_ k, _p1_ v) {
        if (k == _P0E_) {
            throw new IllegalArgumentException("Cannot use _P0E_ as a key!");
        }
        int hash = this.hash(k) & this.mask;

        if (this.keys != null)  {
            _nameP0_ oldKey = this.keys[hash];
            if (this.equals(oldKey, _P0E_))    {
                this.size++;
                this.keys[hash] = k;
            } else if (this.nequals(oldKey, k))  {
                throw new IllegalStateException("Hash collision! old:" + oldKey + ", new:" + k);
            }
        }
        this.values[hash] = v;
    }

    @Override
    public boolean putAndCheck(_p0_ k, _p1_ v)    {
        if (k == _P0E_) {
            throw new IllegalArgumentException("Cannot use _P0E_ as a key!");
        }
        int hash = this.hash(k) & this.mask;

        boolean present = false;
        if (this.keys != null)  {
            _nameP0_ oldKey = this.keys[hash];
            if (!(present = this.nequals(oldKey, _P0E_)))    {
                this.size++;
                this.keys[hash] = k;
            } else if (this.nequals(oldKey, k))  {
                throw new IllegalStateException("Hash collision! old:" + oldKey + ", new:" + k);
            }
        }
        this.values[hash] = v;
        return present;
    }

    @Override
    public _p1_ putAndGet(_p0_ k, _p1_ v) {
        if (k == _P0E_) {
            throw new IllegalArgumentException("Cannot use _P0E_ as a key!");
        }
        int hash = this.hash(k) & this.mask;

        if (this.keys != null)  {
            _nameP0_ oldKey = this.keys[hash];
            if (this.equals(oldKey, _P0E_))    {
                this.size++;
                this.keys[hash] = k;
            } else if (this.nequals(oldKey, k))  {
                throw new IllegalStateException("Hash collision! old:" + oldKey + ", new:" + k);
            }
        }
        <1%@SuppressWarnings("unchecked")%>
        _p1_ oldVal = _castP1_this.values[hash];
        this.values[hash] = v;
        return oldVal;
    }

    @Override
    public _p1_ replace(_p0_ k, _p1_ v) {
        if (k == _P0E_) {
            throw new IllegalArgumentException("Cannot use _P0E_ as a key!");
        }
        int hash = this.hash(k) & this.mask;

        if (this.keys != null)  {
            _nameP0_ oldKey = this.keys[hash];
            if (this.equals(oldKey, _P0E_))    {
                return _P1E_;
            } else if (this.nequals(oldKey, k))  {
                throw new IllegalStateException("Hash collision! old:" + oldKey + ", new:" + k);
            }
        }
        <1%@SuppressWarnings("unchecked")%>
        _p1_ oldVal = _castP1_this.values[hash];
        this.values[hash] = v;
        return oldVal;
    }

    @Override
    public void remove(_p0_ k)  {
        if (k == _P0E_) {
            throw new IllegalArgumentException("Cannot use _P0E_ as a key!");
        }
        int hash = this.hash(k) & this.mask;
        if (this.keys != null)  {
            _nameP0_ oldKey = this.keys[hash];
            if (this.equals(oldKey, _P0E_))    {
                return;
            } else if (this.nequals(oldKey, k))  {
                throw new IllegalStateException("Hash collision! old:" + oldKey + ", new:" + k);
            }
            this.keys[hash] = _P0E_;
        }
        this.values[hash] = _P1E_;
    }

    /**
     * Removes the entry with the given key.
     * <p>
     * If no entry with the given key exists, this method does nothing.
     *
     * @param k the key to be removed
     * @return the value previously mapped to the given key, or {@code _P1E_} if the given key was not present
     */
    boolean removeAndCheck(_p0_ k);

    /**
     * Removes the entry with the given key.
     * <p>
     * If no entry with the given key exists, this method does nothing.
     *
     * @param k the key to be removed
     * @return whether or not the given key could be found in the map (and therefore whether or not it was removed)
     */
    _p1_ removeAndGet(_p0_ k);

    /**
     * Retrieves the value mapped to the given key.
     *
     * @param k the key of the value to get
     * @return the value mapped to the given key, or {@code _P1E_} if the given key was not present
     */
    _p1_ get(_p0_ k);

    /**
     * Checks whether a given key is present in the map.
     *
     * @param k the key to check for
     * @return whether or not the given key is present
     */
    boolean containsKey(_p1_ k);

    /**
     * Passes each key in this map to the given function.
     *
     * @param consumer the function to run
     */
    default void forEachKey(_P0_Consumer_GP0_consumer) {
        if (consumer == null)   {
            throw new NullPointerException("consumer");
        } else {
            this.forEach((k, v) -> consumer.accept(k));
        }
    }

    /**
     * Passes each value in this map to the given function.
     *
     * @param consumer the function to run
     */
    default void forEachValue(_P1_Consumer_GP1_consumer) {
        if (consumer == null)   {
            throw new NullPointerException("consumer");
        } else {
            this.forEach((k, v) -> consumer.accept(v));
        }
    }

    /**
     * Passes each pair in this map to the given function.
     *
     * @param consumer the function to run
     */
    void forEach(_P0__P1_BiConsumer_gH_ consumer);

    @Override
    public int size()   {
        return this.size;
    }

    @Override
    public void clear()    {
        this.size = 0;
        java.util.Arrays.fill(this.values, _P1E_);
        if (this.keys != null)  {
            java.util.Arrays.fill(this.keys, _P0E_);
        }
    }

    @Override
    public void release()   {
        this.keys = null;
        this.values = null;
    }

    protected int hash(_p0_ k) {
        return _hashP0|k|_
    }

    protected boolean equals(_p0_ a, _p0_ b)    {
        return _equalsP0|a|b|_;
    }

    protected boolean nequals(_p0_ a, _p0_ b)    {
        return _nequalsP0|a|b|_;
    }
}
