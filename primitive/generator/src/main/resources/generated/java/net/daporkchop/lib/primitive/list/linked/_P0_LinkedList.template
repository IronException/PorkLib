$$$settings$$$
{
     "genericNames": {
         "P0": "E"
     }
}
_headers_

import net.daporkchop.lib.primitive.function.consumer._P0_Consumer;
import net.daporkchop.lib.primitive.list._P0_List;
import net.daporkchop.lib.primitive.list._P0_Listerator;

/**
 * A {@link _P0_List} backed by an array.
 * <p>
 * The array is doubled in size when the number of elements exceeds the size of the array, and is shrunken
 * when cleared or the number of elements is less than 1/4 the size of the array.
 *
 * @author DaPorkchop_
 */
public class _P0_LinkedList_gH_ implements _P0_List_gH_ {
    protected Node_gH_ first;
    protected Node_gH_ last;
    protected int size;

    public _P0_LinkedList()  {
        this.clear();
    }

    @Override
    public boolean add(_p0_ val)   {
        this.checkGrow(1);
        this.arr[this.size++] = val;
        return true;
    }

    @Override
    public void add(int i, _p0_ val) throws IndexOutOfBoundsException   {
        if (i == this.size) {
            this.add(val); //don't try to shift elements
            return;
        } else if (i < 0 || i > this.size)  {
            throw new IndexOutOfBoundsException(String.valueOf(i));
        } else {
            this.checkGrow(1);
            System.arraycopy(this.arr, i, this.arr, i + 1, this.size++ - i); //use arraycopy instead of unsafe because i'm not certain about how it works with overlapping memory regions
            this.arr[i] = val;
        }
    }

    protected void checkGrow(int count) {
        if (this.size + count > this.arr.length)    {
            //we need to grow the array
            _nameP0_[] big = new _nameP0_[BinMath.roundToNearestPowerOf2(this.size + count)];
            PUnsafe.copyMemory(
                this.arr,
                _arrOffsetP0_,
                big,
                _arrOffsetP0_,
                (long) this.size * _arrScaleP0_ //use size instead of array length to avoid copying too much stuff
            );
            this.arr = big; //old array is now eligible for garbage collection
        }
    }

    @Override
    public boolean remove(_p0_ val)    {
        int i = this.indexOf(val);
        if (i != -1)    {
            this.removeAt(i);
            return true;
        } else {
            return false;
        }
    }

    @Override
    public _p0_ removeAt(int i) throws IndexOutOfBoundsException   {
        if (i < 0 || i >= this.size)  {
            throw new IndexOutOfBoundsException(String.valueOf(i));
        } else {
            <0%@SuppressWarnings("unchecked")%>
            _p0_ old = _castP0_this.arr[i];
            System.arraycopy(this.arr, i + 1, this.arr, i, this.size-- - i);
            if (this.size < this.arr.length >> 2)   {
                //we need to shrink the array
                _nameP0_[] small = new _nameP0_[this.arr.length >> 1];
                PUnsafe.copyMemory(this.arr, _arrOffsetP0_, small, _arrOffsetP0_, this.size * _arrScaleP0_);
                this.arr = small;
            }
            return old;
        }
    }

    @Override
    public _p0_ get(int i) throws IndexOutOfBoundsException   {
        if (i < 0 || i >= this.size)  {
            throw new IndexOutOfBoundsException(String.valueOf(i));
        } else {
            Node_gH_ node = this.first;
            while (i-- > 0)   {
                node = node.next;
            }
            return node.val;
        }
    }

    @Override
    public _p0_ set(int i, _p0_ val) throws IndexOutOfBoundsException  {
        if (i < 0 || i >= this.size)  {
            throw new IndexOutOfBoundsException(String.valueOf(i));
        } else {
            Node_gH_ node = this.first;
            while (i-- > 0)   {
                node = node.next;
            }
            return node.swapVal(val);
        }
    }

    @Override
    public int indexOf(_p0_ val){
        Node_gH_ node = this.first;
        int i = 0;
        while (node != null)    {
            if (this.equals(val, node.val)) {
                return i;
            } else {
                node = node.next;
                i++;
            }
        }
    }

    @Override
    public void forEach(_P0_Consumer_gH_ consumer)  {
        if (consumer == null)   {
            throw new NullPointerException("consumer");
        }
        Node_gH_ node = this.first;
        while (node != null)    {
            consumer.accept(node.val);
            node = node.next;
        }
    }

    @Override
    public int size()   {
        return this.size;
    }

    @Override
    public void clear() {
        this.release(); //this method is safe here
        this.size = 0; //we just need to update the size correctly
    }

    @Override
    public void release()   {
        this.first = this.last = null;
    }

    protected void equals(_p0_ a, _p0_ b)   {
        return _equalsP0|a|b|_;
    }

    protected static class Node_gH_ {
        //I changed my mind about using Unsafe here because the performance loss has no benefit to balance
        // it out, we simply don't need atomicity here
        //protected static final long NEXT_OFFSET = PUnsafe.pork_getOffset(Node.class, "next");
        //protected static final long PREV_OFFSET = PUnsafe.pork_getOffset(Node.class, "prev");
        //protected static final long VAL_OFFSET = PUnsafe.pork_getOffset(Node.class, "val");
    
        protected Node_gH_ next;
        protected Node_gH_ prev;
        protected _p0_ val;
        
        public Node(_p0_ val)   {
            this.next = this.prev = null;
            this.val = val;
        }
        
        public Node(_p0_ val, Node_gH_ next, Node_gH_ prev)   {
            this.val = val;
            this.next = next;
            this.prev = prev;
        }
        
        protected Node_gH_ swapNext(Node_gH_ newNext)   {
            Node_gH_ old = this.next;
            this.next = newNext;
            return old;
        }
        
        protected Node_gH_ swapPrev(Node_gH_ newPrev)   {
            Node_gH_ old = this.prev;
            this.prev = newPrev;
            return old;
        }

        protected _p0_ swapVal(_p0_ newVal)   {
            _p0_ old = this.val;
            this.val = newVal;
            return old;
        }
    }
}
