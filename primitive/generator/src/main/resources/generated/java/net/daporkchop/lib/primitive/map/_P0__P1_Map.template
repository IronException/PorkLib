$$$settings$$$
{
    "P0": {
        "blacklist": [
            "boolean",
            "float",
            "double"
        ]
    },
    "genericNames": {
        "P0": "K",
        "P1": "V"
    }
}
_headers_

import net.daporkchop.lib.primitive.function.biconsumer._P0__P1_BiConsumer;
import net.daporkchop.lib.primitive.function.consumer._P0_Consumer;
import net.daporkchop.lib.primitive.function.consumer._P1_Consumer;
import net.daporkchop.lib.primitive.util.Synchronizable;

/**
 * A map represents a collection of key => value pairs (entries).
 * <p>
 * Keys are always distinct, values may be any compatible value (unless the implementation specifies otherwise).
 * <p>
 * Many implementations will refuse to allow {@code _P0E_} as a key, and will throw exceptions if it is used.
 *
 * @author DaPorkchop_
 */
public interface _P0__P1_Map_gH_ extends Synchronizable<_P0__P1_Map_gH_> {
    /**
     * Inserts a new entry using a given key and value.
     * <p>
     * If an entry with the given key already exists, it will be silently replaced.
     *
     * @param k the key to use
     * @param v the value to use
     */
    void put(_p0_ k, _p1_ v);

    /**
     * Inserts a new entry using a given key and value.
     * <p>
     * If an entry with the given key already exists, it will be silently replaced.
     *
     * @param k the key to use
     * @param v the value to use
     * @return whether or not the key was found in the map (and therefore whether or not an old pair was replaced)
     */
    boolean putAndCheck(_p0_ k, _p1_ v);

    /**
     * Inserts a new entry using a given key and value.
     * <p>
     * If an entry with the given key already exists, it will be replaced and the value returned.
     *
     * @param k the key to use
     * @param v the value to use
     * @return the value previously mapped to the given key, or {@code _P1E_} if the given key was not present
     */
    _p1_ putAndGet(_p0_ k, _p1_ v);

    /**
     * Replaces the value mapped to a pre-existing key.
     * <p>
     * If no entry with the given key exists, this method does nothing.
     *
     * @param k the key to use
     * @param v the value to use
     */
    void replace(_p0_ k, _p1_ v);

    /**
     * Replaces the value mapped to a pre-existing key.
     * <p>
     * If no entry with the given key exists, this method does nothing.
     *
     * @param k the key to use
     * @param v the value to use
     * @return whether or not the key was found in the map (and therefore whether or not an old pair was replaced)
     */
    boolean replaceAndCheck(_p0_ k, _p1_ v);

    /**
     * Replaces the value mapped to a pre-existing key.
     * <p>
     * If no entry with the given key exists, this method does nothing.
     *
     * @param k the key to use
     * @param v the value to use
     * @return the value previously mapped to the given key, or {@code _P1E_} if the given key was not present
     */
    _p1_ replaceAndGet(_p0_ k, _p1_ v);

    /**
     * Removes the entry with the given key.
     * <p>
     * If no entry with the given key exists, this method does nothing.
     *
     * @param k the key to be removed
     */
    void remove(_p0_ k);

    /**
     * Removes the entry with the given key.
     * <p>
     * If no entry with the given key exists, this method does nothing.
     *
     * @param k the key to be removed
     * @return whether or not the given key could be found in the map (and therefore whether or not it was removed)
     */
    boolean removeAndCheck(_p0_ k);

    /**
     * Removes the entry with the given key.
     * <p>
     * If no entry with the given key exists, this method does nothing.
     *
     * @param k the key to be removed
     * @return the value previously mapped to the given key, or {@code _P1E_} if the given key was not present
     */
    _p1_ removeAndGet(_p0_ k);

    /**
     * Retrieves the value mapped to the given key.
     *
     * @param k the key of the value to get
     * @return the value mapped to the given key, or {@code _P1E_} if the given key was not present
     */
    _p1_ get(_p0_ k);

    /**
     * Checks whether a given key is present in the map.
     *
     * @param k the key to check for
     * @return whether or not the given key is present
     */
    boolean containsKey(_p1_ k);

    /**
     * Passes each key in this map to the given function.
     *
     * @param consumer the function to run
     */
    default void forEachKey(_P0_Consumer_GP0_consumer) {
        if (consumer == null)   {
            throw new NullPointerException("consumer");
        } else {
            this.forEach((k, v) -> consumer.accept(k));
        }
    }

    /**
     * Passes each value in this map to the given function.
     *
     * @param consumer the function to run
     */
    default void forEachValue(_P1_Consumer_GP1_consumer) {
        if (consumer == null)   {
            throw new NullPointerException("consumer");
        } else {
            this.forEach((k, v) -> consumer.accept(v));
        }
    }

    /**
     * Passes each pair in this map to the given function.
     *
     * @param consumer the function to run
     */
    void forEach(_P0__P1_BiConsumer_gH_ consumer);

    /**
     * @return the number of elements in this collection, or {@link Integer#MAX_VALUE} if the size is too large to fit in an {@code int}
     */
    int size();

    /**
     * For collections that allow more than {@code 2^31 - 1} elements.
     *
     * @return the number of elements in this collection
     */
    default long longSize() {
        return this.size();
    }

    /**
     * Clears this map, removing all pairs.
     * <p>
     * After this method has been invoked, this instance is expected to be reset as if it were a newly created
     * instance.
     */
    void clear();

    /**
     * Clears this map, removing all pairs.
     * <p>
     * Unlike {@link #clear()}, implementations may choose to not completely reset this instance's state, and
     * rather maintain some allocated resources in order to preserve performance. However, by default this is
     * simply a proxy to {@link #clear()}.
     */
    default void removeAll()    {
        this.clear();
    }

    /**
     * Releases any resources allocated by this map.
     * <p>
     * After invoking this method the map should not be used for any purpose, and attempting to invoke
     * any methods on a released map will produce undefined behavior.
     * <p>
     * The behavior of this method is highly implementation-dependant. This may e.g. free directly allocated
     * memory, or simply make resources available for garbage collection.
     * <p>
     * Any actions done by this method are expected to be done automatically when this map instance
     * is garbage collected, this method simply allows doing it explicitly to free up as many resources as possible
     * for performance reasons in some scenarios.
     */
    void release();

    @Override
    default _P0__P1_Map_gH_ sync(Object mutex) {
        throw new UnsupportedOperationException(); //TODO
    }
}
